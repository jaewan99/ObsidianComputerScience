# 12장-3: 동기화 패턴과 스레드 안전성

## 공유 자원 접근 조정을 위한 세마포 사용

- 기본 아이디어: 스레드는 세마포 연산을 사용하여 다른 스레드에게 어떤 조건이 참이 되었음을 알립니다.
    - 계수 세마포를 사용하여 자원 상태를 추적합니다.
    - 이진 세마포를 사용하여 다른 스레드에게 알립니다.

## 생산자-소비자 문제 (The Producer-Consumer Problem)

- 정보를 생성하는 프로세스와 해당 정보를 활용하는 프로세스 간의 상호작용을 중재합니다.
- 생산자는 빈 슬롯을 기다리고, 항목을 버퍼에 삽입한 후 소비자에게 알립니다.
- 소비자는 항목을 기다리고, 버퍼에서 제거한 후 생산자에게 알립니다.
- 예시:
    - 멀티미디어 처리:
        - 생산자가 비디오 프레임(MPEG)을 생성하고, 소비자가 이를 렌더링합니다.
    - 이벤트 기반 그래픽 사용자 인터페이스:
        - 생산자가 마우스 클릭, 마우스 이동, 키보드 입력을 감지하고 해당 이벤트를 버퍼에 삽입합니다.
        - 소비자가 버퍼에서 이벤트를 검색하여 디스플레이를 그립니다.

## n-요소 버퍼에서의 생산자-소비자

- 하나의 뮤텍스와 두 개의 계수 세마포가 필요합니다:
    - `mutex`: 버퍼에 대한 상호 배제적 접근을 강제합니다.
    - `slots`: 버퍼에서 사용 가능한 슬롯의 수를 셉니다.
    - `items`: 버퍼에서 사용 가능한 항목의 수를 셉니다.
    - ![[Pasted image 20251103150548.png]]
- ![[Pasted image 20251103150717.png]]

- ![[Pasted image 20251103150857.png]]

- ![[Pasted image 20251103151225.png]]

- ![[Pasted image 20251103151237.png]]
- `sbuf`라는 공유 버퍼 패키지를 사용하여 구현됩니다.

## 독자-저자 문제 (Readers-Writers Problem)

- 상호 배제 문제의 일반화입니다.
- 문제 설명:
    - 독자(Reader) 스레드는 객체를 읽기만 합니다.
    - 저자(Writer) 스레드는 객체를 수정합니다.
    - 저자는 객체에 대한 배타적 접근 권한을 가져야 합니다.
    - 무제한의 독자가 객체에 접근할 수 있습니다.
- 실제 시스템에서 자주 발생합니다, 예:
    - 온라인 항공 예약 시스템
        - 동시에 읽기는 가능하지만
        - 예약과 같은 쓰기 작업은
        - 상호 배제 방식으로 발생해야 합니다.
    - 멀티스레드 캐싱 웹 프록시

## 독자-저자 문제의 변형

- **첫 번째 독자-저자 문제 (독자 우선)**
    - 저자가 객체 사용 권한을 이미 부여받지 않은 한, 어떤 독자도 대기하게 해서는 안 됩니다.
    - 대기 중인 저자 이후에 도착한 독자는 저자보다 우선순위를 가집니다.
    - 저자가 기아(starvation) 상태에 빠질 수 있습니다.
- **두 번째 독자-저자 문제 (저자 우선)**
    - 저자가 쓰기 준비가 되면, 가능한 한 빨리 쓰기를 수행합니다.
    - 저자 이후에 도착한 독자는, 저자도 대기 중인 경우라도, 반드시 대기해야 합니다.
    - 독자가 기아 상태에 빠질 수 있습니다.
- **기아 (Starvation)** (스레드가 무기한 대기하는 상태)는 두 경우 모두 가능합니다.
 ![[Pasted image 20251103154135.png]]
## 첫 번째 독자-저자 문제에 대한 해결책

```c
// 독자 스레드 코드 (입장)
P(&mutex);          // readcnt를 안전하게 업데이트하기 위해 잠금
readcnt++;
if (readcnt == 1)   // 만약 내가 첫 번째 독자라면
    P(&w);           // 저자를 차단합니다 - 쓰기 중일 때, 저자가 해제할 때까지 기다림
V(&mutex);          // readcnt 업데이트 완료

// ... 읽기 작업 수행 ...

// 독자 스레드 코드 (퇴장)
P(&mutex);
readcnt--;
if (readcnt == 0)   // 만약 내가 마지막 독자라면
    V(&w);           // 저자에게 쓰기 허용
V(&mutex);
```


## 작업자 스레드 풀 (Worker Thread Pool)

![[Pasted image 20251103155508.png]]

- 새로운 연결 요청이 올 때마다 스레드를 생성하고 스레드가 종료될 때마다 제거하는 방식(주문형 생성)은 오버헤드를 발생시킵니다.
- **작업자 스레드 풀 생성** - 미리 생성된 스레드(pre-threaded) 사용
    1. 연결 수락(Accept connection)
    2. 디스크립터 삽입 - 스레드 간에 공유되는 디스크립터
    3. 디스크립터 제거 - 항목이 나타나면 작업자 스레드 중 하나가 해당 항목을 제거하고 클라이언트와 상호작용
        - 상호작용이 끝나면 버퍼의 다음 파일 디스크립터를 확인
        - 스레드를 종료하는 대신 재사용

![[Pasted image 20251103160624.png]]
![[Pasted image 20251103161532.png]]

- `echo_cnt = pthread_once`는 매번 확인되지만 한 번만 호출됨

## 핵심 개념: 스레드 안전성 (Thread Safety)

- 스레드에서 호출되는 함수는 반드시 스레드 안전(thread-safe)해야 함
- **정의**: 함수가 여러 동시성 스레드로부터 반복적으로 호출될 때 항상 올바른 결과를 생성하면 스레드 안전함

### 스레드 불안전 함수의 클래스

- **클래스 1**: 공유 변수를 보호하지 않는 함수
- **클래스 2**: 여러 호출에 걸쳐 상태를 유지하는 함수
- **클래스 3**: 정적 변수에 대한 포인터를 반환하는 함수
- **클래스 4**: 스레드 불안전 함수를 호출하는 함수

## 스레드 불안전 함수 (클래스 1)

- 공유 변수를 보호하지 못함
- **수정**: P와 V 세마포 연산 (또는 뮤텍스) 사용
- **예시**: goodcnt.c
- **문제점**: 동기화 연산이 코드 속도를 저하시킴

## 스레드 불안전 함수 (클래스 2)

- 여러 함수 호출에 걸쳐 지속적인 상태(persistent state)에 의존
- **예시**: 정적 상태에 의존하는 난수 생성기

![[Pasted image 20251103162536.png]]

- 각 스레드가 얻는 난수는 해당 스레드의 이전 시드뿐만 아니라 다른 스레드의 호출에도 의존함

![[Pasted image 20251103162907.png]]

- **수정**: 인수의 일부로 상태 전달
    - 정적 상태 제거
    - `*nextp`는 이제 스레드 스택의 지역 변수
    - 각 호출자는 next의 자체 로컬 복사본을 유지하고 p 포인터를 rand_r에 전달

## 스레드 불안전 함수 (클래스 3)

- 정적 변수에 대한 포인터를 반환함
- **수정 1**: 호출자가 결과를 저장할 변수의 주소를 전달하도록 함수 재작성
    - 호출자와 피호출자 모두 변경 필요
- **수정 2**: 잠금 후 복사(Lock-and-copy)
    - 호출자에게 간단한 변경만 필요 (피호출자에는 없음)
    - 단, 호출자는 메모리 해제 필요

![[Pasted image 20251103163307.png]]

- 래퍼(wrapper) 함수 생성
- P - 한 번에 하나의 스레드만 이 뮤텍스를 가짐
- ctime = 일반적인 ctime 호출
- copy = strcpy - 로컬 문자열 배열 생성

## 스레드 불안전 함수 (클래스 4)

- 스레드 불안전 함수를 호출함
- 하나의 스레드 불안전 함수를 호출하면, 이를 호출하는 전체 함수가 스레드 불안전해짐
- **수정**: 함수가 오직 스레드 안전 함수만 호출하도록 수정

## 재진입 함수 (Reentrant Functions)

- **정의**: 함수가 여러 스레드에 의해 호출될 때 공유 변수에 접근하지 않으면 재진입 가능(reentrant)함
- 스레드 안전 함수의 중요한 부분집합
    - 동기화 연산 불필요
    - 클래스 2 함수를 스레드 안전하게 만드는 유일한 방법은 재진입 가능하게 만드는 것 (예: `rand_r`)

![[Pasted image 20251103164548.png]]

## 스레드 안전 라이브러리 함수

- Standard C 라이브러리의 모든 함수는 스레드 안전함
    - 예시: malloc, free, printf, scanf
- 대부분의 Unix 시스템 호출은 스레드 안전하며, 몇 가지 예외가 있음:

![[Pasted image 20251103164643.png]]

## 레이스 컨디션 (Race condition)

- 이 레이스가 발생할 수 있을까?

![[Pasted image 20251103165702.png]]
![[Pasted image 20251103165528.png]]

### 레이스 테스트

- 레이스가 없다면 각 스레드는 i의 다른 값을 얻음
- 저장된 값들은 0부터 99까지 각각 하나의 복사본으로 구성됨

![[Pasted image 20251103165547.png]]
![[Pasted image 20251103165739.png]]

## 또 다른 걱정: 데드락 (Deadlock)

- **정의**: 프로세스가 결코 참이 되지 않을 조건을 기다리고 있다면 데드락 상태임

### 전형적인 시나리오

- 프로세스 1과 2가 진행하기 위해 두 자원(A와 B)이 필요함
- 프로세스 1은 A를 획득하고, B를 기다림
- 프로세스 2는 B를 획득하고, A를 기다림
- 둘 다 영원히 기다림!

![[Pasted image 20251103170429.png]]

- 잠금은 데드락 가능성을 도입함: 결코 참이 되지 않을 조건을 기다림
- 데드락 영역에 진입하는 어떤 궤적도 결국 데드락 상태에 도달함
- 다른 궤적들은 운 좋게 데드락 영역을 피해감
- 데드락은 종종 비결정적임 (레이스)

![[Pasted image 20251103170647.png]]
![[Pasted image 20251103170819.png]]

### 진행 그래프에서 데드락 회피

- 궤적이 갇힐 방법이 없음
- 프로세스들이 동일한 순서로 락을 획득함
- 락이 해제되는 순서는 중요하지 않음

![[Pasted image 20251103170851.png]]