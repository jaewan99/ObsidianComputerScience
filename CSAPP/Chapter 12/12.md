# 12장: 동시성 프로그래밍

여러 흐름(flow)이 공유 자원에 접근할 때, 프로그램에서 다양한 문제가 발생할 수 있습니다.

## 동시성 프로그램의 고전적인 문제 유형

- **레이스 (Races)**: 결과가 시스템 내 다른 곳의 임의적인 스케줄링 결정에 의존함
  - 예: 비행기 마지막 좌석을 누가 얻는가?
  - 작업 목록(Job-list) - 부모 프로세스가 자식 프로세스를 목록에 추가하기 전에 실행되고 종료됨

- **데드락 (Deadlock)**: 부적절한 자원 할당으로 인해 진행이 막힘
  - 예: 교통 정체
  - printf - 시그널 핸들러에 의해 인터럽트됨 - printf
    - Printf가 터미널 락을 획득했지만, 두 번째 printf는 메인 루틴이 락을 가지고 있기 때문에 획득할 수 없음
    - 따라서 시그널 핸들러의 printf와 시그널 핸들러는 결코 발생하지 않을 이벤트를 기다리게 됨
    - ![[Pasted image 20251103101607.png]]

- **라이브락 (Livelock) / 기아 (Starvation) / 공정성 (Fairness)**: 외부 이벤트 및/또는 시스템 스케줄링 결정으로 인해 하위 작업의 진행이 방해받을 수 있음
  - 예: 줄에 항상 누군가가 당신 앞에 끼어듦

## 반복 서버 (Iterative Servers)

- 반복 서버는 한 번에 하나의 요청을 처리합니다.
  - ![[Pasted image 20251103101819.png]]
  - ![[Pasted image 20251103101840.png]]
- **두 번째 클라이언트는 실제로 어디서 블록될까?**
  - 두 번째 클라이언트가 반복 서버에 연결을 시도함
    - TCP 버퍼링 때문에:
      - connect 호출이 반환됨
        - 비록 연결이 아직 수락되지 않았더라도
        - 서버 측 TCP 관리자가 요청을 큐에 넣음
      - rio_writen 호출이 반환됨
        - 서버 측 TCP 관리자가 입력 데이터를 버퍼링함
      - rio_readlineb 호출이 블록됨!
        - 서버가 아직 읽을 수 있는 어떤 것도 쓰지 않았음

## 반복 서버의 근본적인 결함

- ![[Pasted image 20251103102641.png]]
- 클라이언트 1:
  - 사용자가 점심 먹으러 감
  - 클라이언트 1은 사용자가 데이터를 입력하기를 기다리며 블록됨
- 서버:
  - 서버는 클라이언트 1로부터 데이터를 기다리며 블록됨
- 클라이언트 2:
  - 클라이언트 2는 서버로부터 읽기를 기다리며 블록됨

- 우리는 한 클라이언트가 시스템 내의 다른 모든 클라이언트에게 완전히 영향을 미치고, 다른 그 어떤 클라이언트도 서비스를 받을 수 없는 난처한 상황에 처해 있습니다.
  - 해결책: 대신 동시성 서버(concurrent servers)를 사용하라
  - 동시성 서버는 여러 동시 흐름을 사용하여 여러 클라이언트를 동시에 처리합니다.

## 동시성 서버 작성 접근법

서버가 여러 클라이언트를 동시에 처리하도록 허용
1. **프로세스 기반 (Process-based)**
   - 커널이 여러 논리적 흐름을 자동으로 인터리빙(교차 실행)함
   - 각 흐름은 자신의 전용 주소 공간을 가짐
     - 각 흐름은 독립적이며 커널에 의해 제어됨
2. **이벤트 기반 (Event-based)**
   - 프로그래머가 여러 논리적 흐름을 수동으로 인터리빙함
   - 모든 흐름이 동일한 주소 공간을 공유함
   - I/O 멀티플렉싱(I/O multiplexing)이라는 기술을 사용함
     - 사용자와 프로그래머가 이 흐름을 생성하고 수동으로 인터리빙함.
3. **스레드 기반 (Thread-based)**
   - 커널이 여러 논리적 흐름을 자동으로 인터리빙함
   - 각 흐름이 동일한 주소 공간을 공유함
   - 프로세스 기반과 이벤트 기반의 혼합형
     - 이러한 각 흐름은 스레드에 의해 구현됨

---

### 접근법 #1: 프로세스 기반 서버

- 각 클라이언트에 대해 별도의 프로세스를 생성(spawn)합니다.
  - ![[Pasted image 20251103103417.png]]
- **프로세스 기반 동시성 에코 서버**
  - argv - 서버가 리슨(listen)할 포트 번호를 전달
  - sockaddr_storage - 프로토콜 독립적, IPv4, IPv6를 처리할 수 있을 만큼 충분히 큼
  - listenfd - 리스닝 디스크립터 생성
  - ![[Pasted image 20251103104453.png]]
  - 자식 서버만 connfd가 필요함
  - ![[Pasted image 20251103104527.png]]

- **동시성 서버: accept 설명**
  1. 서버는 accept에서 블록하며, 리스닝 디스크립터 listenfd에 대한 연결 요청을 기다림
  2. 클라이언트는 connect를 호출하여 연결 요청을 생성
  3. 서버는 accept로부터 connfd를 반환함. 클라이언트를 처리하기 위해 자식 프로세스를 생성(fork)함. clientfd와 connfd 사이에 연결이 설정됨
  - ![[Pasted image 20251103104603.png]]

- **프로세스 기반 서버 실행 모델**
  - ![[Pasted image 20251103104846.png]]
  - 각 클라이언트는 독립적인 자식 프로세스에 의해 처리됨
  - 그들 사이에 공유 상태 없음
  - 부모와 자식 모두 listenfd와 connfd의 복사본을 가짐
    - 부모는 connfd를 닫아야 함 (close)
    - 자식은 listenfd를 닫아야 함 (close)

- **프로세스 기반 서버의 문제점**
  - 리스닝 서버 프로세스는 좀비 프로세스(zombie children)를 수거(reap)해야 함
    - 치명적인 메모리 누수를 피하기 위해
  - 부모 프로세스는 자신의 connfd 복사본을 닫아야 함 (close)
    - 커널은 각 소켓/열린 파일에 대해 참조 카운트(reference count)를 유지함
    - fork 이후, refcnt(connfd) = 2
    - refcnt(connfd) = 0이 될 때까지 연결이 닫히지 않음

- **프로세스 기반 서버의 장단점**
  - + 여러 연결을 동시에 처리함.
  - + 깔끔한 공유 모델
    - 디스크립터 (아니오) - 디스크립터의 별도 복사본
    - 파일 테이블 (예)
    - 전역 변수 (아니오)
  - + 간단하고 직관적임.
  - – 프로세스 제어를 위한 추가 오버헤드가 있음.
  - – 프로세스 간에 데이터를 공유하는 것이 간단하지 않음.
    - IPC(InterProcess Communication) 메커니즘이 필요함
      - FIFO's (네임드 파이프)

---

### 접근법 #2: 이벤트 기반 서버

- 서버는 활성 연결 집합을 유지 관리함
  - connfd들과 listenfd의 배열
- 반복:
  - 어떤 디스크립터(connfd들 또는 listenfd)에 대기 중인 입력(pending inputs)이 있는지 결정
    - 예: select 또는 epoll 함수 사용
    - 대기 중인 입력의 도착은 이벤트임
  - listenfd에 입력이 있으면, 연결을 수락(accept)
    - 그리고 새로운 connfd를 배열에 추가
  - 대기 중인 입력이 있는 모든 connfd에 대해 서비스 제공
- **I/O 멀티플렉싱된 이벤트 처리**
  - ![[Pasted image 20251103110456.png]]
  - 왼쪽 - 각 연결에 대한 디스크립터 번호를 기록함

- **이벤트 기반 서버의 장단점**
  - + 하나의 논리적 제어 흐름과 주소 공간.
  - + 디버거로 단계별 실행(single-step)할 수 있음.
  - + 프로세스 또는 스레드 제어 오버헤드가 없음.
    - 단지 connfd들의 목록일 뿐
    - 고성능 웹 서버 및 검색 엔진의 선택된 디자인. 예: Node.js, nginx, Tornado
  - – 프로세스 기반 또는 스레드 기반 디자인보다 코딩이 상당히 더 복잡함
    - 이벤트에 대한 응답으로 얼마나 많은 작업을 수행할지 파악해야 함.
    - 예: 웹 서버
      - 연결된 파일 디스크립터 중 하나에 입력이 들어옴
        - 가장 간단한 방법은 전체 HTTP 요청을 읽는 것임
          - 그리고 전체 요청을 읽을 때까지 반환하지 않음 - 이벤트에 대한 응답으로 수행하는 작업량이 coarse-grained(굵은 입자)임
            - 많은 명령어가 실행됨.
  - – 세밀한(fine-grained) 동시성을 제공하기 어려움.
    - ▪ 예: 부분적인 HTTP 요청 헤더를如何处理
  - – 멀티 코어의 이점을 활용할 수 없음.
    - ▪ 단일 제어 스레드

---

### 접근법 #3: 스레드 기반 서버

- **프로세스의 전통적인 관점**
  - 프로세스 = 프로세스 컨텍스트 + 코드, 데이터, 스택
    - 컨텍스트 - 커널 내의 데이터 구조, 커널이 프로세스에 대해 유지하는 데이터
    - 그리고 전용 주소 공간 = 코드, 데이터, 스택
    - ![[Pasted image 20251103111914.png]]

- **프로세스의 대체 관점**
  - 프로세스 = 스레드 + 코드, 데이터, 커널 컨텍스트
  - ![[Pasted image 20251103112057.png]]
  - 스레드 컨텍스트 = 프로그램 컨텍스트

- **다중 스레드를 가진 프로세스**
  - ![[Pasted image 20251103112800.png]]
  - 여러 스레드가 하나의 프로세스와 연관될 수 있음
    - 각 스레드는 자신의 논리적 제어 흐름을 가짐
    - 각 스레드는 동일한 코드, 데이터, 커널 컨텍스트를 공유함
    - 각 스레드는 지역 변수를 위한 자신의 스택을 가짐
      - but 다른 스레드로부터 보호되지 않음
    - 각 스레드는 자신의 스레드 ID(TID)를 가짐
  - 커널은 각각의 이러한 스레드를 별도의 제어 흐름으로 생성할 수 있으며 프로세스와 유사하게 스케줄링함
  - 하지만 차이점은, 커널이 한 스레드에서 다른 스레드로 컨텍스트 스위칭을 할 때, 저장하고 복원해야 하는 정보가 그렇게 많지 않다는 점입니다. 단지 적은 양의 데이터일 뿐입니다.
    - 매우 낮은 오버헤드

- **스레드의 논리적 관점**
  - 프로세스와 연관된 스레드들은 동료(peers) 풀을 형성함
    - 트리 계층을 형성하는 프로세스와는 다름
    - ![[Pasted image 20251103112911.png]]

- **동시성 스레드**
  - 두 스레드의 흐름이 시간상 겹치면 동시성(concurrent)임
  - 그렇지 않으면 순차적(sequential)임
  - 예시:
    - 동시성: A & B, A&C
    - 순차적: B & C
    - ![[Pasted image 20251103113051.png]]
  - 단일 코어 프로세서
    - 시간 분할(time slicing)로 병렬성을 시뮬레이션함
  - 멀티 코어 프로세서
    - 진정한 병렬성을 가질 수 있음
  - ![[Pasted image 20251103113132.png]]

- **스레드 vs. 프로세스**
  - 스레드와 프로세스가 유사한 점
    - 각각 자신의 논리적 제어 흐름을 가짐
    - 각각 다른 것들과 (아마도 다른 코어에서) 동시에 실행될 수 있음
    - 각각 컨텍스트 스위칭됨
  - 스레드와 프로세스가 다른 점
    - 스레드는 모든 코드와 데이터를 공유함 (보호되지 않는 지역 스택 제외)
      - 프로세스는 (일반적으로) 공유하지 않음 - 자신의 주소 공간을 가짐
    - 스레드는 프로세스보다 다소 저렴함
      - 프로세스 제어(생성 및 수거)는 스레드 제어보다 두 배 비쌈
        - Linux 숫자
          - – 프로세스 생성 및 수거에 약 20K 사이클
          - – 스레드 생성 및 수거에 약 10K 사이클 (또는 그 이하)

- **POSIX 스레드 (Pthreads) 인터페이스**
  - Pthreads: C 프로그램에서 스레드를 조작하는 약 60개의 함수에 대한 표준 인터페이스
    - 스레드 생성 및 수거
      - pthread_create() === fork, but 계층 구조를 생성하지는 않음
      - pthread_join() === wait
    - 자신의 스레드 ID 확인
      - pthread_self() === getpid
    - 스레드 종료
      - pthread_cancel() === kill
      - pthread_exit()
      - exit() (모든 스레드를 종료시킴)
      - return (현재 스레드를 종료시킴)
    - 공유 변수에 대한 동기화된 접근
      - pthread_mutex_init
      - pthread_mutex_[un]lock

- **Pthreads "hello, world" 프로그램**
  - ![[Pasted image 20251103114055.png]]
  - ![[Pasted image 20251103114357.png]]

- **스레드 기반 동시성 에코 서버**
  - ![[Pasted image 20251103114625.png]]
  - ![[Pasted image 20251103114908.png]]
  - vargp - 연결된 파일 디스크립터에 대한 포인터
  - detach - 스레드가 죽으면 커널이 자동으로 데이터를 처리함.
  - free - 메인 스레드에서 생성된 malloc
  - "분리된(detached)" 모드에서 스레드 실행.
    - 다른 스레드들로부터 독립적으로 실행됨
    - 종료 시 자동으로 (커널에 의해) 수거(reaped)됨
  - connfd를 보관하기 위해 할당된 저장 공간을 해제(free)합니다.
  - connfd를 닫습니다 (중요!)

- **스레드 기반 서버 실행 모델**
  - ![[Pasted image 20251103115405.png]]
  - 리스닝 서버 메인 스레드 - accept로 연결 요청을 기다림

- **스레드 기반 서버의 문제점**
  - 스레드를 자동으로 수거/정리하기 위해 "분리된(detached)" 상태로 실행
    - 어떤 시점에서든, 스레드는 조인 가능(joinable)하거나 분리됨(detached)
    - 조인 가능한 스레드는 다른 스레드에 의해 수거되고 종료될 수 있음
      - 메모리 자원을 해제하기 위해 (pthread_join으로) 수거되어야 함
    - 분리된 스레드는 다른 스레드에 의해 수거되거나 종료될 수 없음
      - 자원은 종료 시 자동으로 수거됨
    - 기본 상태는 조인 가능(joinable)
      - 분리되도록 만들기 위해 pthread_detach(pthread_self()) 사용
  - 의도하지 않은 공유를 피하기 위해 주의해야 함
    - 예: 메인 스레드의 스택에 대한 포인터 전달
      - Pthread_create(&tid, NULL, thread, (void *)&connfd);
    - 스레드가 호출하는 모든 함수는 스레드 안전(thread-safe)해야 함

- **스레드 기반 디자인의 장단점**
  - + 스레드 간에 데이터 구조를 공유하기 쉬움
    - 예: 로깅 정보, 파일 캐시
  - + 스레드는 프로세스보다 더 효율적임
  - – 의도하지 않은 공유가 미묘하고 재현하기 어려운 오류를 초래할 수 있음
    - 데이터를 공유하는 용이함은 스레드의 가장 큰 장점이면서 동시에 가장 큰 약점임
    - 어떤 데이터가 공유되고 어떤 데이터가 비공개인지 알기 어려움
    - 테스트로 발견하기 어려움
      - 나쁜 레이스 결과의 확률은 종종 매우 낮음
      - 하지만 0이 아님!
    - 향후 강의에서 다룰 예정