https://www.youtube.com/watch?v=zVcE3Opyk-o&list=PL22J-I2Pi-Gf0s1CGDVtt4vuvlyjLxfem&index=24 
Question: which variables in a threaded c program are shared?
- The answer is not as simple as "global variables are shared" and "stack variables are private".

Threads Memory Model
- Conceptual model:
	- Multiple threads run within the context of a single process
	- Each thread has its own separate thread context
		- Thread ID, stack, stack pointer, PC, condition codes, and GP registers
	- All threads share the remaining process context
		- Code, data, heap, and shared library segments of the process virtual address space
		- Open files and installed handlers
	- Operationally, this model is not strictly enforced:
		- Register values are truly separate and protected, but ...
		- Any thread can read and write the stack of any other thread
		- ![[Pasted image 20251103134557.png]]
		- ![[Pasted image 20251103134147.png]]
	- Mapping Variable Instances to Memory
		- Global variables
			- Def: Variable declared outside of a function
				- Virtual memory contains exactly one instance of any global variable
		- Local variables
			- Def: Variable declared inside function without static attribute
				- Each thread stack contains one instance of each local variable
		- Local static variables
			- Def: Variable declared inside function with the static attribute
				- Virtual memory contains exactly one instance of any local static variable.
	- Answer: A variable x is shared iff multiple threads reference at least one instance of x. Thus:
		- ptr, cnt, and msgs are shared
		- i and myid are not shared
- badcnt.c : Improper Synchronization
	- ![[Pasted image 20251103140929.png]]
	- ![[Pasted image 20251103141148.png]]
- Concurrent Execution
	- Key idea: In general, any sequentially consistent interleaving is possible, but some give an unexpected result!
		- I i denotes that thread i executes instruction I
		- %rdxi is the content of %rdx in thread iâ€™s context
		- ![[Pasted image 20251103141524.png]]
		- This is the interleaving that works, we got the answer that we wanted
	- Concurrent Execution (cont)
		- Incorrect ordering: two threads increment the counter, but the result is 1 instead of 2
		- ![[Pasted image 20251103141811.png]]
		- ![[Pasted image 20251103141830.png]]
- Progress Graph
	- A progress graph depicts the discrete execution state space of concurrent threads.
	- Each axis corresponds to the sequential order of instructions in a thread
	- Each point corresponds to a possible execution state (Inst1 , Inst2 ).
	- E.g., (L1 , S2 ) denotes state where thread 1 has completed L1 and thread 2 has completed S2 .
	- A trajectory is a sequence of legal state transitions that describes one possible concurrent execution of the threads.
	- ![[Pasted image 20251103142449.png]]
	- ![[Pasted image 20251103142501.png]]
- Critical Sections and Unsafe Regions
	- L, U, and S form a critical section with respect to the shared variable cnt
	- Instructions in critical sections (wrt some shared variable) should not be interleaved
	- Sets of states where such interleaving occurs form unsafe regions
	- ![[Pasted image 20251103142603.png]]
	
	- Def: A trajectory is safe iff it does not enter any unsafe region
	- Claim: A trajectory is correct (wrt cnt) iff it is safe
	- ![[Pasted image 20251103142636.png]]
	- Enforcing Mutual Exclusion
		- Question: How can we guarantee a safe trajectory?
			- Answer: We must synchronize the execution of the threads so that they can never have an unsafe trajectory.
				- i.e., need to guarantee mutually exclusive access for each critical section.
		- Classic solution:
			- Mutex (pthreads)
			- Semaphores (Edsger Dijkstra)
		- Other approaches (out of our scope)
			- Condition variables (pthreads)
			- Monitors (Java)