# 12장-2: 스레드와 동기화

질문: 스레드된 C 프로그램에서 어떤 변수들이 공유될까?
- 답은 "전역 변수는 공유되고 스택 변수는 비공개다"처럼 간단하지 않습니다.

## 스레드 메모리 모델

- 개념적 모델:
  - 여러 스레드가 단일 프로세스 컨텍스트 내에서 실행됨
  - 각 스레드는 자신의 별도 스레드 컨텍스트를 가짐
    - 스레드 ID, 스택, 스택 포인터, 프로그램 카운터(PC), 조건 코드, 범용 레지스터
  - 모든 스레드는 나머지 프로세스 컨텍스트를 공유함
    - 코드, 데이터, 힙, 그리고 프로세스 가상 주소 공간의 공유 라이브러리 세그먼트
    - 열린 파일들과 설치된 핸들러들
- 운영상(Operationally), 이 모델은 엄격하게 강제되지 않습니다:
  - 레지스터 값은 진정으로 분리되어 있고 보호되지만, ...
  - 어떤 스레드든 다른 어떤 스레드의 스택도 읽고 쓸 수 있습니다
  - ![[Pasted image 20251103134557.png]]
  - ![[Pasted image 20251103134147.png]]

## 변수 인스턴스를 메모리에 매핑하기

- **전역 변수 (Global variables)**
  - 정의: 함수 외부에 선언된 변수
    - 가상 메모리는 어떤 전역 변수에 대해서도 정확히 하나의 인스턴스를 포함함
- **지역 변수 (Local variables)**
  - 정의: static 속성 없이 함수 내부에 선언된 변수
    - 각 스레드 스택은 각 지역 변수의 하나의 인스턴스를 포함함
- **지역 정적 변수 (Local static variables)**
  - 정의: static 속성과 함께 함수 내부에 선언된 변수
    - 가상 메모리는 어떤 지역 정적 변수에 대해서도 정확히 하나의 인스턴스를 포함함

- 답변: 변수 x는 여러 스레드가 x의 적어도 하나의 인스턴스를 참조할 경우에만 공유됩니다. 따라서:
  - ptr, cnt, msgs는 **공유됨**
  - i와 myid는 **공유되지 않음**

## badcnt.c: 부적절한 동기화

- ![[Pasted image 20251103140929.png]]
- ![[Pasted image 20251103141148.png]]

## 동시 실행 (Concurrent Execution)

- 핵심 개념: 일반적으로, 순차적으로 일관된(sequentially consistent) 인터리빙(interleaving)이 가능하지만, 일부는 예상치 못한 결과를 초래합니다!
  - I i 는 스레드 i가 명령어 I를 실행함을 나타냄
  - %rdxi 는 스레드 i의 컨텍스트에서 %rdx의 내용임
  - ![[Pasted image 20251103141524.png]]
  - 이것은 작동하는 인터리빙이며, 우리가 원하는 답을 얻었습니다.

## 동시 실행 (계속)

- 올바르지 않은 순서: 두 스레드가 카운터를 증가시키지만, 결과는 2가 아닌 1입니다.
- ![[Pasted image 20251103141811.png]]
- ![[Pasted image 20251103141830.png]]

## 진행 그래프 (Progress Graph)

- 진행 그래프는 동시성 스레드들의 이산 실행 상태 공간을描绘합니다.
- 각 축은 스레드 내 명령어들의 순차적 순서에 대응합니다.
- 각 점은 가능한 실행 상태 (Inst1, Inst2)에 대응합니다.
- 예: (L1, S2)는 스레드 1이 L1을 완료하고 스레드 2가 S2를 완료한 상태를 나타냅니다.
- 궤적(Trajectory)은 스레드들의 하나의 가능한 동시 실행을 설명하는 합법적인 상태 전환의 순서입니다.
- ![[Pasted image 20251103142449.png]]
- ![[Pasted image 20251103142501.png]]

## 임계 구역(Critical Sections)과 안전하지 않은 영역(Unsafe Regions)

- L, U, S는 공유 변수 cnt에 대해 하나의 임계 구역을 형성합니다.
- (어떤 공유 변수에 대한) 임계 구역 내의 명령어들은 인터리빙되어서는 안 됩니다.
- 그러한 인터리빙이 발생하는 상태들의 집합이 안전하지 않은 영역(unsafe regions)을 형성합니다.
- ![[Pasted image 20251103142603.png]]

- 정의: 궤적이 어떤 안전하지 않은 영역에도 진입하지 않으면 안전(safe)합니다.
- 주장: 궤적이 (cnt에 대해) 올바르다(correct) iff 그것은 안전(safe)합니다.
- ![[Pasted image 20251103142636.png]]

## 상호 배제(Mutual Exclusion) 강제

- 질문: 어떻게 안전한 궤적을 보장할 수 있을까?
  - 답변: 스레드들의 실행을 동기화하여 그들이 결코 안전하지 않은 궤적을 갖지 않도록 해야 합니다.
    - 즉, 각 임계 구역에 대해 상호 배제적 접근을 보장해야 합니다.
- 고전적인 해결책:
  - 뮤텍스 (Mutex, pthreads)
  - 세마포 (Semaphores, Edsger Dijkstra)
- 다른 접근법 (범위를 벗어남):
  - 조건 변수 (Condition variables, pthreads)
  - 모니터 (Monitors, Java)

## 세마포 (Semaphores)

- 세마포: 음수가 아닌 전역 정수형 동기화 변수. P와 V 연산에 의해 조작됩니다.
- **P(s)**
  - 만약 s가 0이 아니면, s를 1 감소시키고 즉시 반환합니다.
    - 테스트 및 감소 연산은 원자적으로(atomically, 나눌 수 없게) 발생합니다.
  - 만약 s가 0이면, s가 0이 아니게 될 때까지 스레드를 중단(suspend)시키고, V 연산에 의해 스레드가 재시작됩니다.
  - 재시작 후, P 연산은 s를 감소시키고 호출자에게 제어를 반환합니다.
- **V(s)**:
  - s를 1 증가시킵니다.
    - 증가 연산은 원자적으로 발생합니다.
  - 만약 s가 0이 되기를 기다리며 P 연산에서 블록된 스레드들이 있다면, 그 스레드들 중 정확히 하나를 재시작하며, 그 스레드는 s를 감소시켜 자신의 P 연산을 완료합니다.
- 세마포 불변식: s ≥ 0
- ![[Pasted image 20251103143934.png]]

## 상호 배제를 위한 세마포 사용

- 기본 아이디어:
  - 각 공유 변수(또는 관련된 공유 변수 집합)에 대해 초기값이 1인 고유한 세마포 mutex를 연결(associate)시킵니다.
  - 해당 임계 구역을 P(mutex)와 V(mutex) 연산으로 둘러씁니다.
- 용어:
  - **이진 세마포 (Binary semaphore)**: 값이 항상 0 또는 1인 세마포
  - **뮤텍스 (Mutex)**: 상호 배제를 위해 사용되는 이진 세마포
    - P 연산: 뮤텍스를 "잠금(locking)"
    - V 연산: 뮤텍스를 "잠금 해제(unlocking)" 또는 "해제(releasing)"
    - 뮤텍스를 "보유(Holding)"한다: 잠금되었고 아직 잠금 해제되지 않음.
  - **계수 세마포 (Counting semaphore)**: 사용 가능한 자원 집합에 대한 카운터로 사용됨.
- ![[Pasted image 20251103144409.png]]

## 뮤텍스가 작동하는 이유

- 임계 구역을 lock과 unlock 연산으로 둘러싸서 공유 변수에 대한 상호 배제적 접근을 제공합니다.
- 뮤텍스 불변식은 안전하지 않은 영역을 포함하고 어떤 궤적도 진입할 수 없는 금지 영역(forbidden region)을 생성합니다.
- ![[Pasted image 20251103144938.png]]