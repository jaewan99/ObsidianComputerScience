https://www.youtube.com/watch?v=OynSMXfNtiM&list=PL22J-I2Pi-Gf0s1CGDVtt4vuvlyjLxfem&index=21

A Client-Server Transaction
- Most network applications are based on the client-server model:
	- A server process and one or more client processes
	- Server manages some resource
	- Server provides service by manipulating resource for clients
	- Server activated by request from client (vending machine analogy
	- ![[Pasted image 20251031165649.png]]
- ![[Pasted image 20251031165735.png]]
	- From the hardware perspective, the interface to a between the network and your computer is called NIC, or network interface card
		- ![[Pasted image 20251031170714.png]]
		- Network interface card
		- The interesting thing is that it looks to your computer like an I/O device
		- And unix API dealing with networks, make it looks like a file.
- Computer Networks
	- A network is a hierarchical system of boxes and wires organized by geographical proximity
		- SAN (System Area Network) spans cluster or machine room
			- Switched Ethernet, Quadrics QSW, ...
		- LAN (Local Area Network) spans a building or campus
			- Ethernet is most prominent example
		- WAN (Wide Area Network) spans country or world
			- Typically high-speed point-to-point phone lines
	- An internetwork (internet) is an interconnected set of networks
		- The Global IP Internet (uppercase "I") is the most famous example of an internet (lowercase "i")
- Lowest Level: Ethernet Segment
	- ![[Pasted image 20251031171146.png]]
	- Ethernet segment consists of a collection of hosts connected by wires (twisted pairs) to a hub
		-  Sharing a single communication channel
	- Spans room or floor in a building
	- Operation
		- Each Ethernet adapter has a unique 48-bit address (MAC address)
			- E.g., 00:16:ea:e3:54:e6
		- Hosts send bits to any other host in chunks called frames
		- Hub slavishly copies each bit from each port to every other port
			- Every host sees every bit
		- Note: Hubs are obsolete. Bridges (switches, routers) became cheap enough to replace them
- Next Level: Bridged Ethernet Segment
	- ![[Pasted image 20251031171158.png]]
	- Spans building or campus
	- Bridges cleverly learn which hosts are reachable from which ports and then selectively copy frames from port to port
- Conceptual View of LANs
	- For simplicity, hubs, bridges, and wires are often shown as a collection of hosts attached to a single wire:
	- Bunch of hosts, where they can easily communication on one other
	- ![[Pasted image 20251031171326.png]]
- Next Level: internets
	- Multiple incompatible LANs can be physically connected by specialized computers called routers
	- The connected networks are called an internet (lower case)
	- ![[Pasted image 20251031171416.png]]
	- LAN 1 and LAN 2 might be completely different, totally incompatible (e.g., Ethernet, Fibre Channel, 802.11*, T1-links, DSL, …)
- Logical Structure of an internet
	- Whole bunch of host spread potentially all across the world and then some magical system of routers that will get a message from one place to the other, based on the mode of addressing. And it will hub through multiple routers to get from one place to the other.
	- ![[Pasted image 20251031171722.png]]
	- Ad hoc interconnection of networks
		- No particular topology
		- Vastly different router & link capacities
	- Send packets from source to destination by hopping through networks
		- Router forms bridge from one network to another
		- Different packets may take different routes
- The Notion of an internet Protocol
	- How is it possible to send bits across incompatible LANs and WANs?
	- Solution: protocol software running on each host and router
		- Protocol is a set of rules that governs how hosts and routers should cooperate when they transfer data from network to network.
		- Smooths out the differences between the different networks
- What Does an internet Protocol Do?
	- Provides a naming scheme
		- An internet protocol defines a uniform format for host addresses
		- Each host (and router) is assigned at least one of these internet addresses that uniquely identifies it
	- Provides a delivery mechanism
		- An internet protocol defines a standard transfer unit (packet)
			- packets are around 1000-2000 bytes
		- Packet consists of header and payload
			- Header: contains info such as packet size, source and destination addresses
			- Payload: contains data bits sent from source host
- Transferring internet data via encapsulation
	- we want to send a packet from Host A to Host B
	- ![[Pasted image 20251031173341.png]]
	- Idea of packet communication
		-  Put little headers on that contain the routing information equivalent on the front of an envelope of a letter
	- The LAN1 adapter, the network interface card or adaptor 
		- is responsible for putting that out over this local communication capability
	- LAN2 - puts its own frame header
		- Encapsulation, decapsulation.
- Global IP Internet
	- Based on the TCP/IP protocol family
		- IP (Internet Protocol)
			- Provides basic naming scheme and unreliable delivery capability of packets (datagrams) from host-to-host
		- UDP (Unreliable Datagram Protocol)
			- Uses IP to provide unreliable datagram delivery from process-to-process
		- TCP (Transmission Control Protocol) - 99%
			- Uses IP to provide reliable byte streams from process-to-process over connections
	- Accessed via a mix of Unix file I/O and functions from the sockets interface
- Hardware and Software Organization of a Client-Server Internet Application
	- ![[Pasted image 20251031173824.png]]
- A Programmer’s View of the Internet
	- 1. Hosts are mapped to a set of 32-bit IP addresses
		- 128.2.203.179
		- 127.0.0.1 (always localhost)
		- passed and stored in network byte order which is big endian byte order
	- 2. The set of IP addresses is mapped to a set of identifiers called Internet domain names
		- 128.2.217.3 is mapped to www.cs.cmu.edu
			- 128.2... == cmu
	- 3. A process on one Internet host can communicate with a process on another Internet host over a connection
- Aside: IPv4 and IPv6
	- The original Internet Protocol, with its 32-bit addresses, is known as Internet Protocol Version 4 (IPv4)
	- 1996: Internet Engineering Task Force (IETF) introduced Internet Protocol Version 6 (IPv6) with 128-bit addresses
		- Intended as the successor to IPv4
- (1) IP Addresses
	- 32-bit IP addresses are stored in an IP address struct
		- IP addresses are always stored in memory in network byte order (big-endian byte order)
		- True in general for any integer transferred in a packet header from one machine to another.
			- E.g., the port number used to identify an Internet connection.
			- ![[Pasted image 20251031174449.png]]
		- Useful network byte-order conversion functions ("I" = 32 bits, "s" = 16 bits)
			- htonl : convert uint32_t from host to network byte order
			- htons : convert uint16_t from host to network byte order
			- ntohl : convert uint32_t from network to host byte order
			- ntohs : convert uint16_t from network to host byte order
- Dotted Decimal Notation
	- By convention, each byte in a 32-bit IP address is represented by its decimal value and separated by a period
		- IP address: 0x8002C2F2 = 128.2.194.242 (Big Endian)
	- Functions for converting between binary IP addresses and dotted decimal strings:
		- inet pton: dotted decimal string > IP address in network byte order
		- inet_ntop: IP address in network byte order > dotted decimal string
		- "n" denotes network
		- "p" denotes presentation
- Domain Naming System (DNS)
	- The Internet maintains a mapping between IP addresses and domain names in a huge worldwide distributed database called DNS
	- Conceptually, programmers can view the DNS database as a collection of millions of host entries.
		- Each host entry defines the mapping between a set of domain names and IP addresses.
		- In a mathematical sense, a host entry is an equivalence class of domain names and IP addresses.
	- We can think of a big database that gives me a mapping where I can give a domain name and it will get back to me a one or more IP addresses. Or the other way, I can give an IP address and it will come back with one or more domain names.
- Properties of DNS Mappings
	- Can explore properties of DNS mappings using nslookup
	- Each host has a locally defined domain name localhost which always maps to the loopback address 127.0.0.1
	- ![[Pasted image 20251031180146.png]]
	- Use hostname to determine real domain name of local host:
	- ![[Pasted image 20251031180158.png]]
	- Simple case: one-to-one mapping between domain name and IP address:
	- ![[Pasted image 20251031180355.png]]
	- Multiple domain names mapped to the same IP address:
	- ![[Pasted image 20251031180411.png]]
	- Multiple domain names mapped to multiple IP addresses:
	- ![[Pasted image 20251031180443.png]]
	- Some valid domain names don’t map to any IP address:
	- ![[Pasted image 20251031180459.png]]
- (3) Internet Connections
	- Clients and servers communicate by sending streams of bytes over connections. Each connection is:
		- Point-to-point: connects a pair of processes.
		- Full-duplex: data can flow in both directions at the same time,
		- Reliable: stream of bytes sent by the source is eventually received by the destination in the same order it was sent.
	- A socket is an endpoint of a connection
		- Socket address is an IPaddress:port pair
	- A port is a 16-bit integer that identifies a process
		- Ephemeral port: Assigned automatically by client kernel when client makes a connection request.
			- Usually connected with the limited amount of time
		- Well-known port: Associated with some service provided by a server (e.g., port 80 is associated with Web servers)
- Well-known Service Names and Ports
	- Popular services have permanently assigned well-known ports and corresponding well-known service names:
		- echo servers: echo 7
		- ftp servers: ftp 21
		- ssh servers: ssh 22
		- email servers: smtp 25
		- Web servers: http 80
	- Mappings between well-known ports and service names is contained in the file /etc/services on each Linux machine.
- Anatomy of a Connection
	- A connection is uniquely identified by the socket addresses of its endpoints (socket pair)
		- (cliaddr:cliport, servaddr:servport)
	- ![[Pasted image 20251031180940.png]]
	- ![[Pasted image 20251031181021.png]]
- Sockets Interface
	- Set of system-level functions used in conjunction with Unix I/O to build network applications
	- Created in the early 80’s as part of the original Berkeley distribution of Unix that contained an early version of the Internet protocols.
	- Available on all modern systems
		- Unix variants, Windows, OS X, IOS, Android, ARM
- Sockets
	- What is a socket?
		- To the kernel, a socket is an endpoint of communication
		- To an application, a socket is a file descriptor that lets the application read/write from/to the network
			- Remember: All Unix I/O devices, including networks, are modeled as files
	- Clients and servers communicate with each other by reading from and writing to socket descriptors
	- ![[Pasted image 20251031181254.png]]
	- The main distinction between regular file I/O and socket I/O is how the application “opens” the socket descriptors
-  Socket Address Structures
	- Generic socket address:
		- For address arguments to connect, bind, and accept (next lecture)
		- Necessary only because C did not have generic (void *) pointers when the sockets interface was designed
		- For casting convenience, we adopt the Stevens convention:
			- typedef struct sockaddr SA;
		- sa_family - designated what type of socket this is - TPC socket, IPv6 socket, UDP socket 
		- ![[Pasted image 20251031185314.png]]
	- Internet (IPv4) specific socket address:
		- Must cast (struct sockaddr_in *) to (struct sockaddr *) for functions that take socket address arguments.
		- ![[Pasted image 20251031185352.png]]
		- Still in big endian
		- it's like a subclass of sockaddr
- Echo server and client structure
	- ![[Pasted image 20251031185746.png]]
- The first step in on either side in creating a connection is a call to a function to socket
- ![[Pasted image 20251031191347.png]]
	- the socket returns an int which is the file descriptor 
- Socket interface: bind
	- A server uses bind to ask the kernel to associate the server's socket address with a socket descriptor:
		- ![[Pasted image 20251031191744.png]]
	- The process can read bytes that arrive on the connection whose endpoint is addr by reading from descriptor sockfd.
	- Similarly, writes to sockfd are transferred along connection whose endpoint is addr.
	- Best practice is to use getaddrinfo to supply the arguments addr and addrlen.
	- This designates which particular service this program is going to be hosting
- Sockets Interface: listen
	- By default, kernel assumes that descriptor from socket function is an active socket that will be on the client end of a connection.
	- A server calls the listen function to tell the kernel that a descriptor will be used by a server rather than a client:
	- ![[Pasted image 20251031192145.png]]
	- 
	- Converts sockfd from an active socket to a listening socket that can accept connection requests from clients.
	- backlog is a hint about the number of outstanding connection requests that the kernel should queue up before starting to refuse requests.
- Sockets Interface: accept
	- Servers wait for connection requests from clients by calling accept:
	- ![[Pasted image 20251031192438.png]]
	- Waits for connection request to arrive on the connection bound to listenfd, then fills in client's socket address in addr and size of the socket address in addrlen.
	- Returns a connected descriptor that can be used to communicate with the client via Unix I/O routines.
	- 
- Socket interface : connect
	- A client establishes a connection with a server by calling connect:
		- ![[Pasted image 20251031192912.png]]
	- Attempts to establish a connection with server at socket address addr
		- If successful, then clientfd is now ready for reading and writing.
		- Resulting connection is characterized by socket pair
			- (x:y, addr.sin_addr:addr.sin_port)
			- x is client address
			- y is ephemeral port that uniquely identifies client process on client host
- Accept Illustrated
	- ![[Pasted image 20251031192631.png]]
		- The server went through bind and listen. It created listening port from that which is t the one that its listening for connection requests on
		- From the client's socket sends out the connection request that goes out over the network and lands on the server and the kernel hands that off to the program that's running on that particular port. And hands it off to that call be handled by call to accept by the server.
		- Accept returns a new file descriptor which the server will then use as its connection point to this particular client
			- As a server be handling multiple clients at the same time
			- Same port different file descriptors
- Host and Service Conversion: getaddrinfo
	- getaddrinfo is the modern way to convert string representations of hostnames, host addresses, ports, and service names to socket address structures.
		- Replaces obsolete gethostbyname and getservbyname funcs
	- Advantages:
		- Reentrant (can be safely used by threaded programs).
		- Allows us to write portable protocol-independent code
			- Works with both IPv4 and IPv6
	- Disadvantages
		- Somewhat complex
		- Fortunately, a small number of usage patterns suffice in most cases.
	- Given host and service, getaddrinfo returns result that points to a linked list of addrinfo structs, each of which points to a corresponding socket address struct, and which contains arguments for the sockets interface functions.
	- Helper functions:
		- freeadderinfo frees the entire linked list
		- gai_strerror converts error code to an error message
		- ![[Pasted image 20251031194337.png]]
	- Linked List Returned by getaddrinfo
		- ![[Pasted image 20251031194546.png]]
		- Clients: walk this list, trying each socket address in turn the calls to socket and connect succeed.
		- Servers: walk the list until calls to socket and bind
- addrinfo Struct
	- ![[Pasted image 20251031194730.png]]
	- Each addrinfo struct returned by getaddrinfo contains arguments that can be passed directly to socket function
	- Also points to a socket address struct that can be passed directly to connect and bind functions.
	- ![[Pasted image 20251031195415.png]]
	- ![[Pasted image 20251031195437.png]]
	- ![[Pasted image 20251031195516.png]]
	- ![[Pasted image 20251031200218.png]]
- getnameinfo
	- ![[Pasted image 20251031201459.png]]
- Client - Connect
	- Establish a  connection with a server
	- ![[Pasted image 20251031202245.png]]
	- ![[Pasted image 20251031202537.png]]
- Sockets Helper: open_listenfd
	- Create a listening descriptor that can be used to accept connection requests from the client
	- ![[Pasted image 20251031203143.png]]
	- ![[Pasted image 20251031203548.png]]
	- ![[Pasted image 20251031203632.png]]

- Echo Server Example
	- ./echoserveri (iterative - one client - in this case one cmd at a time) 15213
		- 
	- ./echoclient localhost 15213
		- ![[Pasted image 20251031204224.png]]
- Echo Client
	- ![[Pasted image 20251031204520.png]]
- Iterative Echo Server: Main Routine
	- ![[Pasted image 20251031204942.png]]
- Echo Server: echo function
	- The server uses RIO to read and echo text lines until EOF (end-of-file) condition is encountered.
		- EOF condition caused by client calling close(clientfd)
		- ![[Pasted image 20251031205100.png]]
- Testing Servers Using telnet
	- The telnet program is invaluable for testing servers that transmit ASCII strings over Internet connections
		- Our simple echo server
		- Web servers
		- Mail servers
- Web Server Basics
	- Clients and servers communicate using the HyperText Transfer Protocol (HTTP)
		- Client and server establish TCP connection
		- Client requests content
		- Server responds with requested content
		- Client and server close connection (eventually)
	- Current version is HTTP/1.1
		- RFC 2616, June, 1999
		- HTTP/2 is so different that it might as well be a new protocol.
		- ![[Pasted image 20251031205607.png]]
- Web Content
	- Web servers return content to clients
		- content: a sequence of bytes with an associated MIME (Multipurpose Internet Mail Extensions) type
		- Content is identified by its URL (Uniform Resource Locator)
	- Example MIME types
		- text/html - HTML document
		- text/plain - Unformatted text
		- image/gif - Binary image encoded in GIF format
		- image/png - Binary image encoded in PNG format
		- image/jpeg - Binary image encoded in JPEG format
- Static and Dynamic Content
	- Static content: content stored in files and retrieved in response to an HTTP request
		- Examples: HTML files, images, audio clips, Javascript programs
		- Request identifies which content file
	- Dynamic content: content produced on-the-fly in response to an HTTP request
		- Example: content produced by a program executed by the server on behalf of the client
		- Request identifies file containing executable code
	- Any URL can refer to either static or dynamic content
- URLs and how clients and servers use them
	- Unique name for a file: URL (Universal Resource Locator)
	- Example URL: http://www.cmu.edu:80/index.html
	- Clients use prefix (http://www.cmu.edu:80) to infer:
		- What kind (protocol) of server to contact (HTTP)
		- Where the server is (www.cmu.edu)
		- What port it is listening on (80)
	- Servers use suffix (/index.html) to:
		- Determine if request is for static or dynamic content.
			- No hard and fast rules for this
			- One convention: executables reside in cgi-bin directory
		- Find file on file system
			- Initial “/” in suffix denotes home directory for requested content.
			- Minimal suffix is “/”, which server expands to configured default filename (usually, index.html)
- HTTP Requests 
	- HTTP request is a request line, followed by zero or more request headers

	- Request line:  
	- method uri version
	- method is one of GET, POST, OPTIONS, HEAD, PUT, DELETE, or TRACE
	- uri is typically URL for proxies, URL suffix for servers
		- A URL is a type of URI (Uniform Resource Identifier)
	- version is HTTP version of request (HTTP/1.0 or HTTP/1.1)
	- Request headers:
		- provide additional information to the server (e.g. brand name of the browser)
- HTTP Responses
	- HTTP response is a response line followed by zero or more response headers, possibly followed by content, with blank line (“\r\n”) separating headers from content.
	- Response line:
		- version status_code status_msg
		- version is HTTP version of the response
		- status code is numeric status
		- status msg is corresponding English text
			- 200 OK - Request was handled without error
			- 301 Moved - Provide alternate URL
			- 404 Not found - Server couldn’t find the file
	- Response headers: header_name: header_data
		- provide additional information about response
		- Content-Type: MIME type of content in response body
		- Content-Length: Length of content in response body
		- ![[Pasted image 20251031211522.png]]
- Tiny Web Server
	- Tiny Web server described in text
		- Tiny is a sequential Web server
		- Serves static and dynamic content to real browsers
			- text files, HTML files, GIF, PNG, and JPEG images
		- 239 lines of commented C code
		- Not as complete or robust as a real Web server
			- You can break it with poorly-formed HTTP requests (e.g., terminate lines with “\n” instead of “\r\n”)
- Tiny Operation
	- Accept connection from client
	- Read request from client (via connected socket)
	- Split into method uri version
		- If method not GET, then return error
	- If URI contains “cgi-bin” then serve dynamic content
		- (Would do wrong thing if had file “abcgi-bingo.html”)
		- Fork process to execute program
	- Otherwise serve static content
		- Copy file to output
- Tiny serving static content
	- ![[Pasted image 20251031212323.png]]
- Serving Dynamic Content
	- Client sends request to server
	- If request URI contains the string “/cgi-bin”, the Tiny server assumes that the request is for dynamic content
	- ![[Pasted image 20251031212744.png]]
	- The server creates a child process and runs the program identified by the URI in that process
	- ![[Pasted image 20251031212800.png]]
	- Issues in Serving Dynamic Content
		- How does the client pass program arguments to the server?
		- How does the server pass these arguments to the child?
		- How does the server pass other info relevant to the request to the child?
		- How does the server capture the content produced by the child?
		- These issues are addressed by the Common Gateway Interface (CGI) specification.
		- ![[Pasted image 20251031212847.png]]
		- ![[Pasted image 20251031212901.png]]
- Serving Dynamic Content With GET
	- Question: How does the client pass arguments to the server?
		- Answer: The arguments are appended to the URI
	- Can be encoded directly in a URL typed to a browser or a URL in an HTML link
		- adder is the CGI program on the server that will do the addition.
		- argument list starts with “?”
		- arguments separated by “&”
		- spaces represented by “+” or “%20”
- Serving Dynamic Content With GET
	- Question: How does the server pass these arguments to the child?
	- Answer: In environment variable QUERY_STRING
		- A single string containing everything after the “?”
		- For add: QUERY_STRING = “15213&18213”
		- ![[Pasted image 20251031213202.png]]
- Serving Dynamic Content with GET
	- Question: How does the server capture the content produced by the child?
	- Answer: The child generates its output on stdout. Server uses dup2 to redirect stdout to its connected socket.
	- ![[Pasted image 20251031213411.png]]
- Serving Dynamic Content with GET
	- Notice that only the CGI child process knows the content type and length, so it must generate those headers.
	- The one that forked out and execved
	- ![[Pasted image 20251031213528.png]]
	- ![[Pasted image 20251031213844.png]]
	- ![[Pasted image 20251031213958.png]]
	- 