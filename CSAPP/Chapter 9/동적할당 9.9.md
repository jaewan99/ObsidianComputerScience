# 동적 메모리 할당

프로그래머는 런타임에 가상 메모리를 획득하기 위해 동적 메모리 할당자(예: malloc)를 사용합니다.
- 크기가 런타임에만 알려지는 데이터 구조용
동적 메모리 할당자는 힙(heap)이라고 알려진 프로세스 가상 메모리 영역을 관리합니다.

할당자는 힙을 할당되었거나 사용 가능한 가변 크기 블록들의 모음으로 유지합니다.
- 할당됨(Allocated): 어떤 프로그램/애플리케이션이 사용 중임을 의미
- 사용 가능(Free): 애플리케이션이 사용할 수 있음을 의미

할당자는 힙을 할당되었거나 사용 가능한 가변 크기 블록들의 모음으로 유지합니다.

## 할당자 유형

- **명시적 할당자(Explicit allocator)**: 애플리케이션이 공간을 할당하고 해제
    - 예: C 언어의 malloc과 free
    - 시스템은 사용자가 하지 않는 한 할당한 메모리를 해제하지 않습니다.
- **암시적 할당자(Implicit allocator)**: 애플리케이션이 할당하지만, 공간을 해제하지는 않음
    - 예: Java, ML, Lisp의 가비지 컬렉션
    - 시스템이 메모리 해제를 처리합니다.
        - 메모리 해제의 부담이 애플리케이션 프로그램에서 시스템으로 이전됩니다.
        - 가비지 컬렉션이라는 프로세스를 사용하여 백그라운드에서 이 메모리를 암시적으로 해제합니다.

---

## [03:30] malloc 패키지

- `#include <stdlib.h>`
- `void *malloc(size_t size)`
    - 메모리를 할당하는 데 사용되는 함수이며, 바이트 단위의 크기 인수를 입력으로 받고, 최소한 입력 크기 바이트를 포함하는 메모리 블록에 대한 포인터를 반환합니다.
    - 성공 시:
        - 최소한 size 바이트 크기의 메모리 블록에 대한 포인터를 반환하며, 8바이트(x86) 또는 16바이트(x86-64) 경계에 정렬됩니다.
    - 실패 시: NULL(0)을 반환하고 errno를 설정합니다.
- `void free (void *p)`
    - p가 가리키는 블록을 사용 가능한 메모리 풀로 반환합니다.
    - p는 이전의 malloc 또는 realloc 호출에서 와야 합니다.
- 기타 함수
    - `calloc`: 할당된 블록을 0으로 초기화하는 malloc의 버전
    - `realloc`: 이전에 할당된 블록의 크기를 변경합니다.
    - `sbrk`: 할당자가 내부적으로 힙을 늘리거나 줄이기 위해 사용됩니다.
        - 할당자에게 더 많은 메모리가 필요할 때, sbrk를 호출하여 추가 가상 메모리를 얻습니다.

---

## [05:44] malloc 및 free의 동작 방식 다이어그램

![[Pasted image 20251024160958.png]]

---

## [07:29] 본 강의에서의 가정

- 메모리는 워드 주소 지정 방식입니다 (각 워드는 포인터를 보유할 수 있음) -하지만 바이트 주소 지정이며, 워드는 4바이트입니다.
- 블록은 할당되거나 사용 가능한 연속된 워드 덩어리입니다.
- (1) 여기에는 4워드 할당 블록과 그 뒤를 잇는 2워드 사용 가능 블록으로 구성된 힙의 일부가 있습니다.

![[Pasted image 20251024161412.png]]

![[Pasted image 20251024161657.png]]

- 할당자는 충분한 공간을 가진 사용 가능한 블록을 찾으려고 시도하고, 5개의 사용 가능한 워드를 가진 이 사용 가능 블록을 찾은 다음, 해당 사용 가능 블록 내부에 요청된 블록을 할당합니다.

---

## [10:11] 제약 조건

- 애플리케이션
    - malloc 및 free 요청의 임의의 시퀀스를 발행할 수 있습니다.
    - free 요청은 malloc된 블록에 대해 이루어져야 합니다.
- 할당자
    - 할당된 블록의 수나 크기를 제어할 수 없습니다.
    - malloc 요청에 즉시 응답해야 합니다.
        - 즉, 요청을 재정렬하거나 버퍼링할 수 없습니다.
    - 사용 가능한 메모리에서 블록을 할당해야 합니다.
        - 즉, 할당된 블록은 사용 가능한 메모리에만 배치할 수 있습니다.
    - 모든 정렬 요구사항을 충족하도록 블록을 정렬해야 합니다.
        - Linux 상자에서 8바이트(x86) 또는 16바이트(x86-64) 정렬
    - 사용 가능한 메모리만 조작하고 수정할 수 있습니다.
    - 일단 malloc된 할당된 블록은 이동시킬 수 없습니다.
        - 즉, 압축(compaction)은 허용되지 않습니다.

---

## [12:35] 성능 목표: 처리량(Throughput)

- malloc 및 free 요청의 어떤 시퀀스가 주어졌을 때:
    - R0, R1, ..., Rk, ..., R(n-1)
- 목표: 처리량과 최고 메모리 활용률 극대화
    - 이러한 목표는 종종 상충됩니다.
- 처리량(Throughput):
    - 단위 시간당 완료된 요청 수
        - 예시:
            - 10초 동안 5,000번의 malloc 호출과 5,000번의 free 호출
            - 처리량은 1,000 operations/second
- malloc이 애플리케이션의 이러한 요청을 얼마나 효율적으로 처리하는지 측정합니다.

## 성능 목표: 최고 메모리 활용률(Peak Memory Utilization)

- 할당자가 힙을 얼마나 효율적으로 사용하는지 측정합니다.
    - 할당자가 구현에서 사용해야 하는 데이터 구조에서 얼마나 낭비되는지
- malloc 및 free 요청의 어떤 시퀀스가 주어졌을 때:
    - R0, R1, ..., Rk, ..., R(n-1)

    - 정의: 총 페이로드(Aggregate payload) Pk
        - malloc(p)는 p 바이트의 페이로드를 가진 블록을 결과로 냅니다.
        - 요청 Rk가 완료된 후, 총 페이로드 Pk는 현재 할당된 페이로드들의 합입니다.
        - 애플리케이션이 malloc을 호출할 때, 특정 크기 블록을 요청합니다. 그 블록을 페이로드(payload)라고 합니다. 따라서 10바이트 인수로 malloc을 호출하면, 최소 크기 10의 페이로드를 가진 블록을 요청하는 것입니다.
        - 우리가 요청한 10바이트를 페이로드라고 합니다.
        - 그 블록의 다른 모든 것은 오버헤드입니다.
        - 완벽한 할당자 - 총 페이로드는 메모리 양(모든 할당된 블록의 총 크기)과 같을 것입니다. 왜냐하면 오버헤드가 없기 때문입니다.
            - 모든 블록은 순수한 페이로드일 것입니다.

    - 정의: 현재 힙 크기 Hk
        - Hk가 단조 비감소(monotonically nondecreasing)한다고 가정합니다.
            - 즉, 할당자가 sbrk를 사용할 때만 힙이 증가합니다.
        - 실제 malloc 패키지에서는 사실이 아닙니다.

    - 정의: k+1 요청 후의 최고 메모리 활용률
        - ![[Pasted image 20251024164200.png]]
        - 모든 페이로드의 합을 힙의 총 크기로 나눈 값
        - 최상의 경우 - 각 블록이 순수한 페이로드로 구성됨 - 따라서 활용률은 1
        -실제로는，할당자가 각 블록 내부에 데이터 구조와 패딩을 배치하기 때문에 완벽한 활용률을 얻지 못합니다.
        - 한 가지 명백한 것은 블록이 정렬되어야 하기 때문입니다. 16바이트 정렬이라면 블록은 16바이트 경계에서 시작해야 하고, 최소 16바이트여야 합니다.
            - 따라서 2바이트의 페이로드를 요청하면, 활용률을 감소시키는 많은 바이트가 낭비될 것입니다.

---

## [17:21] 단편화(Fragmentation)

- 단편화로 인한 나쁜 메모리 활용률
    - 내부 단편화(internal fragmentation)
    - 외부 단편화(external fragmentation)

### 내부 단편화(Internal fragmentation)

- 주어진 블록에 대해, 페이로드가 블록 크기보다 작으면 내부 단편화가 발생합니다.
- ![[Pasted image 20251024165232.png]]
- 원인:
    - 블록 내의 패딩이나 할당자가 필요한 데이터 구조에 의해 발생할 수 있습니다.
    - 힙 데이터 구조 유지 관리의 오버헤드
    - 정렬을 위한 패딩
    - 명시적 정책 결정 (예: 작은 요청을 충족시키기 위해 큰 블록 반환)
- 이전 요청 패턴에만 의존합니다.
    - 따라서 측정하기 쉬움
    - 언제든지 우리가 만든 모든 이전 요청을 살펴보고, 각 요청의 페이로드 크기를 확인하여 내부 단편화 수준을 결정할 수 있습니다.

### 외부 단편화(External fragmentation)

- 총 힙 메모리는 충분하지만, 단일 사용 가능 블록이 충분히 크지 않을 때 발생합니다.
    - 애플리케이션이 블록을 요청했지만, 힙 어디에도 그 요청을 충족시킬 만큼 큰 사용 가능 블록이 없을 때.
- ![[Pasted image 20251024165923.png]]
- 힙의 총 사용 가능 워드 수는 7워드입니다. 그리고 이제 6워드에 대한 요청을 받습니다.
    - 할당자는 더 많은 가상 메모리를 가져와서 충분히 큰 사용 가능 블록을 얻기 위해 이런 식으로 힙을 확장해야 합니다.
- 미래 요청의 패턴에 의존합니다.
    - 따라서 측정하기 어렵습니다.

---

## [21:44] 구현 문제

- 포인터만 주어졌을 때, 얼마나 많은 메모리를 해제해야 하는지 어떻게 알까요?
- 사용 가능한 블록을 어떻게 추적할까요?
- 할당하는 구조가 배치되는 사용 가능 블록보다 작을 때 여분의 공간으로 무엇을 해야 할까요?
- 할당에 사용할 블록을 어떻게 선택할까요 — 여러 개가 맞을 수 있습니다.
- 해제된 블록을 어떻게 다시 삽입할까요?

---

## [23:16] 해제할 양을 아는 방법

- 표준 방법
    - 블록의 길이를 블록 바로 앞의 워드에 보관합니다.
        - 이 워드는 종종 헤더 필드(header field) 또는 헤더(header)라고 불립니다.
    - 모든 할당된 블록에 대해 추가 워드가 필요합니다.
- **![[Pasted image 20251024171537.png]]
- 애플리케이션이 크기 4의 페이로드를 malloc하면, 할당자는 크기 5의 블록을 찾아야 합니다.
    - 최소 4개의 페이로드 워드와 그 시작 부분에 해당 블록의 전체 크기를 나타내는 헤더 워드(헤더 블록)로 구성되며, 이 경우 페이로드의 시작 부분에 대한 포인터 p0를 반환합니다.

---

## [24:27] 사용 가능 블록 추적하기

### 방법 1: 암시적 리스트(Implicit List)

- ![[Pasted image 20251024172607.png]]
- 블록의 크기를 알기 때문에 다음 블록의 시작을 알 수 있습니다.
- 사용 가능 블록의 리스트는 없지만, 힙의 모든 블록을 순회하고 할당된 블록은 무시함으로써 힙의 모든 사용 가능 블록을 순회할 수 있습니다.

### 방법 2: 명시적 리스트(Explicit List)

- ![[Pasted image 20251024172748.png]]
- 블록 내의 워드를 사용하여 단일 연결 리스트 또는 이중 연결 리스트를 생성할 수 있습니다.
    - 여기서 첫 번째 사용 가능 블록을 방문하고 다음 사용 가능 블록에 대한 포인터가 있고 이런 식입니다.
    - 이것은 조금 더 효율적일 수 있습니다. 왜냐하면 사용 가능 리스트를 순회하려면 방법 1은 선형 시간이 걸리지만, 이 방법을 사용하면 순회는 사용 가능 리스트의 크기에 대해 선형 시간이 될 것입니다.

### 방법 3: 분리된 명시적 리스트(Segregated Explicit List)

- ![[Pasted image 20251024174239.png]]
    - 각각 특정 크기 또는 특정 크기 범위의 블록을 포함하는 여러 개의 사용 가능 리스트를 가질 수 있습니다.
    - 요청에서 매우 인기 있는 크기 클래스가 있다면, 해당 요청을 처리하기 위해 특별한 경우의 사용 가능 리스트를 만들 수 있습니다.

### 방법 4: 블록 정렬을 위한 균형 트리(Balanced Tree for Block Sorting)

- ![[Pasted image 20251024174339.png]]
    - 균형 트리(예: Red-Black tree)를 사용하여 블록을 정렬하고 크기 순으로 정렬하는 데 트리를 사용할 수 있습니다.

---

## [31:33] 방법 1: 암시적 리스트(Implicit List) 상세

- 각 블록에 대해 크기와 할당 상태 모두 필요
    - 이 정보를 두 워드에 저장할 수 있습니다: 낭비!
- 표준 트릭
    - 블록이 정렬되어 있으면,몇몇 하위 주소 비트는 항상 0입니다.
    - 항상 0인 비트를 저장하는 대신, 할당/사용 가능 플래그로 사용합니다.
    - 크기 워드를 읽을 때, 이 비트를 마스크 아웃해야 합니다.
- ![[Pasted image 20251024191913.png]]
    - 8바이트 정렬 블록은 크기가 8이어야 하고 8의 배수인 주소에서 시작해야 합니다.
    - 블록 크기(실제 크기를 보유한 값)는 항상 3 또는 4개의 하위 비트가 0으로 설정됩니다.
        - 우리는 그 하위 비트를 할당 상태 저장에 사용하고, 나머지 비트는 크기에 해당합니다.
            - 크기를 추출하려면 할당 상태를 마스크 아웃하고 항상 0으로 설정하기만 하면 됩니다.

![[Pasted image 20251024193152.png]]

- (1) - 8바이트로 구성된 사용 가능 블록을 나타냅니다.
- (2) - 16바이트(2워드) 할당
    - 다음 블록 페이로드가 8바이트 정렬 경계에서 시작하도록 하기 위해 이 여분의 블록을 유지해야 하는 내부 단편화입니다.
- (3) - 사용 가능 블록을 병합하기 시작할 때某种 특수 경우를 제거합니다.
    - 종료 시에도 유용합니다.

---

## [36:56] 암시적 리스트: 사용 가능 블록 찾기

- **최초 적합(First fit)**:
    - 처음부터 리스트를 검색하고, 맞는 첫 번째 사용 가능 블록을 선택합니다.
    - ![[Pasted image 20251024193241.png]]
    - 총 블록 수(할당 및 사용 가능)에 대해 선형 시간이 걸릴 수 있습니다.
    - 실제로 리스트 시작 부분에 "파편(splinters)"을 유발할 수 있습니다.
    - 예: 크기 10의 블록을 요청하고, 힙의 시작 부분에서 시작하여 힙을 walked하며, 크기가 최소 10(헤더 크기 더하기)인 사용 가능 블록을 찾습니다.
- **다음 적합(Next fit)**:
    - 최초 적합과 유사하지만, 이전 검색이 끝난 곳에서 리스트 검색을 시작합니다.
    - 최초 적합보다 종종 더 빨라야 합니다: 도움이 되지 않는 블록을 다시 스캔하는 것을 피합니다.
    - 몇몇 연구에 따르면 단편화가 더 나쁩니다 / 심해질 수 있습니다.
- **최적 적합(Best fit)**:
    - 리스트를 검색하고, 가장 적합한 사용 가능 블록을 선택합니다: 맞으면서 힙에 남은 바이트가 가장 적은 블록.
    - 조각을 작게 유지합니함으로 메모리 활용률을 향상시킵니다.
    - 일반적으로 최초 적합보다 느리게 실행됩니다.

---

## [40:31] 암시적 리스트: 사용 가능 블록 내 할당

- 사용 가능 블록 내 할당: 분할(Splitting)
    - 할당된 공간이 사용 가능 공간보다 작을 수 있으므로, 블록을 분할하고 싶을 수 있습니다.
    - ![[Pasted image 20251024193939.png]]
    - malloc 패키지가 애플리케이션 요청을 충족시키기 위해 헤더를 포함한 크기 4의 블록이 필요하다고 판단하면.
    - ![[Pasted image 20251024194218.png]]

---

## [42:48] 암시적 리스트: 블록 해제

- 가장 간단한 구현:
    - "할당됨" 플래그만 지우면 됩니다.
        - ![[Pasted image 20251024194556.png]]
    - 그러나 "가짜 단편화(false fragmentation)"를 초래할 수 있습니다.
    - ![[Pasted image 20251024194655.png]]
    - 충분한 사용 가능 공간이 있지만, 할당자는 추가할 수 없습니다.

---

## [43:58] 암시적 리스트: 병합(Coalescing)

- 다음/이전 블록과 결합(병합)합니다,  만약 free하다면.
    - 다음 블록과 병합
    - ![[Pasted image 20251024195049.png]]
    - 하지만 "이전" 블록과는 어떻게 병합할까요?
        - 이전 블록을 확인하려면 매우 처음부터 시작하여 전체 힙을 walked해야 하기 때문에 힙의 크기에 대해 선형 시간이 걸릴 것입니다.

---

## [46:19] 암시적 리스트: 양방향 병합(Bidirectional Coalescing)

- Knuth73의 경계 태그(Boundary tags)
    - "Bottom(footer)"(끝)에 크기/할당 상태 워드를 복제합니다.
    - "리스트"를 역방향으로 순회할 수 있게 하지만, 추가 공간이 필요합니다.
    - 중요하고 일반적인 기술!
    - ![[Pasted image 20251024195642.png]]
    - 해제하려는 블록이 주어지면, 그 블록의 크기는 메모리에서 한 워드 앞에 있을 것이므로 항상 한 워드의 고정 오프셋입니다.
        - 따라서 블록의 헤더에 대한 포인터가 주어지면, 한 워드 뒤를 보아 이전 블록의 크기와 할당 상태를 확인할 수 있습니다.
        - 이는 블록을 상수 시간에 해제할 수 있게 합니다.
        - ![[Pasted image 20251024200030.png]]
        - 중요한 것은 크기와 할당 상태가 동일하다는 것입니다.

---

## [48:34] 상수 시간 병합(Constant time coalescing)

- ![[Pasted image 20251024200450.png]]
- 경우 1
    - ![[Pasted image 20251024200524.png]]
- 경우 2
    - ![[Pasted image 20251024200621.png]]
- 경우 3
    - ![[Pasted image 20251024200720.png]]
- 경우 4
    - ![[Pasted image 20251024200751.png]]

---

## [52:30] 경계 태그의 단점

- 추가적인 내부 단편화를 생성할 수 있습니다 - 단점은 오버헤드입니다.
- **최적화할 수 있을까요?**
    - **어떤 블록이 푸터 태그가 필요할까요?**
    - **그것은 무엇을 의미할까요?**
    - **할당된 블록은 푸터/경계 태그가 필요하지 않습니다.**
        - **8바이트 정렬이 있다면**
            - **종료 비트는 암시적으로 알고 있습니다.**
                - **첫 번째는 블록에 속함**
                - **이전 블록이 할당된 경우 두 번째 할당된 비트**

---

## [59:51] 주요 할당자 정책 요약

- **배치 정책(Placement policy)**:
    - 최초 적합, 다음 적합, 최적 적합 등.
    - 더 낮은 처리량과 더 적은 단편화를 맞바꿈
    - 흥미로운 관찰: 분리된 사용 가능 리스트(다음 강의)는 전체 사용 가능 리스트를 검색하지 않고도 최적 적합 배치 정책을 근사합니다.
- **분할 정책(Splitting policy)**:
    - 언제 사용 가능 블록을 분할할까요?
    - 우리가 감수할 내부 단편화는 얼마나 될까요?
- **병합 정책(Coalescing policy)**:
    - 즉시 병합(Immediate coalescing): free가 호출될 때마다 병합합니다.
    - 지연 병합(Deferred coalescing): 필요할 때까지 병합을 미루어 free의 성능을 향상시키려고 시도합니다.
        - 예시:
            - malloc을 위해 사용 가능 리스트를 스캔하는 동안 병합
            - 외부 단편화 양이 임계값에 도달할 때 병합

---

## [1:04:43] 암시적 리스트: 요약

- 구현: 매우 간단
- 할당 비용:
    - 최악의 경우 선형 시간
- 해제 비용:
    - 최악의 경우 상수 시간
    - 병합이 있어도
- 메모리 사용량:
    - 배치 정책에 따라 달라짐
    - 최초 적합, 다음 적합 또는 최적 적합
- 선형 시간 할당 때문에 malloc/free에 실제로 사용되지 않음
    -특수 목적 애플리케이션에서 사용됨
- 그러나 분할 및 경계 태그 병합의 개념은 "모든" 할당자에 대해 일반적입니다.

---

# 동적 메모리 할당: 고급 개념

## 명시적 사용 가능 리스트(Explicit free list)

- 사용 가능 블록의 본체 내부에 이중 연결 리스트를 구현하는 포인터를 넣습니다.
- ![[Pasted image 20251025190236.png]]
- 할당자는 할당된 블록의 페이로드 내부의 어떤 것도 건드릴 수 없습니다. 아무도 사용 가능 블록을 사용하지 않으므로, 할당자는 이전 페이로드였던 곳 내부에 해당 데이터 구조를 구현하는 포인터를 넣을 수 있습니다.
- 모든 블록이 아닌 사용 가능 블록의 리스트를 유지합니다.
    - "다음" 사용 가능 블록은 어디든지 있을 수 있습니다.
        - 따라서 크기뿐만 아니라 순방향/역방향 포인터를 저장해야 합니다.
    - 병합을 위해 경계 태그가 필요합니다.
    - 다행히 우리는 사용 가능 블록만 추적하므로, 페이로드 영역을 사용할 수 있습니다.
- ![[Pasted image 20251025190456.png]]

---

## [10:29] 명시적 리스트에서 할당

- ![[Pasted image 20251025192130.png]]
- 아이디어는 우리가 이 중간 블록에서 할당하려는 것입니다.
    - 따라서, 필요한 크기의 블록을 할당합니다.
    - 그리고 나서 이전 및 다음 블록의 순방향 및 역방향 포인터만 업데이트합니다.
- 6개의 포인터 업데이트

---

## [23:40] 명시적 사용 가능 리스트로 해제하기

- **삽입 정책(Insertion policy)**: 새로 해제된 블록을 사용 가능 리스트의 어디에 넣을까요?
- **LIFO (후입선출) 정책**
    - 해제된 블록을 사용 가능 리스트의 시작 부분에 삽입합니다.
    - 장점: 간단하고 상수 시간
    - 단점: 연구에 따르면 단편화가 주소 순서보다 나쁩니다.
    - 리스트의 시작 부분에 넣습니다. 따라서 마지막으로 해제된 블록은 맞는다면 첫 번째로 할당되는 블록입니다.
- **주소 순서 정책(Address-ordered policy)**
    - 해제된 블록을 삽입하여 사용 가능 리스트 블록이 항상 주소 순서가 되도록 합니다:
        - addr(prev) < addr(curr) < addr(next)
    - 단점: 검색이 필요합니다.
    - 장점: 연구에 따르면 단편화가 LIFO보다 낮습니다.
    - 삽입할 적절한 위치를  찾기 위해 검색해야 합니다.

---

## [28:22] LIFO 정책으로 해제하기 (경우 1)

- ![[Pasted image 20251025193256.png]]
- 사용 가능 블록은 사용 가능 리스트의 첫 번째 블록입니다.
- 루트를 이 새로 해제된 블록을 가리키도록 업데이트하고, 해당 블록의 순방향 포인터를 힙의 첫 번째 블록이었던 것을 가리키도록 업데이트합니다.

### LIFO 정책으로 해제하기 (경우 2)

- ![[Pasted image 20251025193605.png]]
- 이전 블록을 연결에서 제거하고, 두 메모리 블록을 병합한 다음, 새 블록을 리스트의 루트에 삽입합니다.
- 최적화 - 병합할 때, 우리는 그 블록을 사용 가능 리스트에 그대로 두고, 아무것도 업데이트하지 않고, 헤더와 푸터를 조정하여 이 새로 병합된 블록을 생성할 수 있습니다.

### LIFO 정책으로 해제하기 (경우 3)

- ![[Pasted image 20251025194216.png]]
- 다음 블록을 연결에서 제거하고, 두 메모리 블록을 병합한 다음, 새 블록을 리스트의 루트에 삽입합니다.

### LIFO 정책으로 해제하기 (경우 4)

- ![[Pasted image 20251025194402.png]]

---

## 명시적 리스트 요약

- 암시적 리스트와 비교:
    - 할당(Allocate)은 모든 블록 대신 사용 가능 블록 수에 대한 선형 시간입니다.
        - 대부분의 메모리가 가득 찼을 때 훨씬 빠릅니다.
    - 블록을 리스트에서 연결 및 연결 해제해야 하기 때문에 할당 및 해제가 약간 더 복잡합니다.
    - 링크를 위한 추가 공간이 필요합니다 (각 블록마다 2개의 추가 워드 필요).
        - 이것이 내부 단편화를 증가시킬까요?
        - 더 많은 오버헤드를 생성합니다.
- 연결 리스트의 가장 일반적인 사용은 분리된 사용 가능 리스트와 결합되어 있습니다.
    - 다른 크기 클래스에 대한 여러 연결 리스트를 유지하거나, possibly 다른 유형의 객체에 대해 유지합니다.

---

## [39:03] 방법 3: 분리된 리스트(Segregated list)

- 각 크기 클래스의 블록은 자신의 사용 가능 리스트를 가집니다.
- ![[Pasted image 20251025194852.png]]
- 종종 각 작은 크기에 대해 별도의 클래스를 가집니다.
- 더 큰 크기의 경우: 2의 거듭제곱 크기마다 하나의 클래스

---

## [40:11] 분리된 리스트 할당자(Seglist Allocator)

-한 크기 클래스에 대한 사용 가능 리스트 배열이 주어졌을 때
- 크기 n의 블록을 할당하려면:
    - 크기 m > n인 블록에 대해 적절한 사용 가능 리스트를 검색합니다.
    - 적절한 블록을 찾으면:
        - 블록을 분할하고 조각을 적절한 리스트에 배치합니다 (선택 사항).
    - 블록을 찾지 못하면, 다음 더 큰 클래스를 시도합니다.
    - 블록을 찾을 때까지 반복합니다.
- 블록을 찾지 못하면:
    - OS에 추가 힙 메모리를 요청합니다 (sbrk() 사용).
    - 이 새 메모리에서 n 바이트의 블록을 할당합니다.
    - 나머지를 가장 큰 크기 클래스의 단일 사용 가능 블록으로 배치합니다.
- 블록을 해제하려면:
    - 병합하고 적절한 리스트에 배치합니다.
- 분리된 리스트 할당자의 장점
    -더 높은 Throughput 처리량
        - 2의 거듭제곱 크기 클래스에 대해 로그 시간
    -더 좋은 메모리 활용률
        - 분리된 사용 가능 리스트의 최초 적합 검색은 전체 힙의 최적 적합 검색을 근사합니다.
        - 극단적인 경우: 각 블록에 자체 크기 클래스를 부여하는 것은 최적 적합과 동등합니다.

---

## [45:59] 여기서 중단