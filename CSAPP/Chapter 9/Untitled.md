[파일 이름]: 제목 없음.md
[파일 내용 시작]
- [48:01](https://www.youtube.com/watch?v=z-Vp5W1qHK8#t=48:01.70)
- 가비지 컬렉션
    - 메모리 관리자는 언제 메모리를 해제할 수 있는지 어떻게 알까요?
        - 일반적으로 조건문에 따라 달라지기 때문에 미래에 무엇이 사용될지 알 수 없습니다.
        - 하지만 특정 블록에 대한 포인터가 없는 경우 해당 블록이 사용될 수 없다는 것은 알 수 있습니다.
    - 포인터에 대한 특정 가정을 해야 합니다.
        - 메모리 관리자는 포인터와 비포인터를 구분할 수 있습니다.
            - C 언어에서는 불가능합니다. 포인터는 그냥 정수 값일 뿐입니다. 데이터 구조를 가리킬 수도 있고, 그냥 큰 정수일 수도 있습니다. 우리는 알 수 없습니다.
        - 모든 포인터는 블록의 시작 부분을 가리킵니다.
            - C 언어에서도 사실이 아닙니다. 따라서 포인터라고 식별했을 때 그것이 어떤 블록을 가리킨다는 것은 알 수 있습니다. 하지만 블록 내부를 가리킨다면 그 블록의 시작 부분을 어떻게 찾을 수 있을까요?
            - 헤더가 크기를 알려주는 블록의 시작 부분을 가리켜야 합니다.
        - 포인터를 숨길 수 없습니다.
            - (예: 포인터를 int로 강제 변환(Coercing)했다가 다시 되돌리는 경우)

- [50:20](https://www.youtube.com/watch?v=z-Vp5W1qHK8#t=50:20.78)
- 고전적인 GC 알고리즘
    - 표시-쓸기(Mark-and-sweep) 수집 (McCarthy, 1960)
        - 블록을 이동시키지 않습니다 ("압축(compact)"하지 않는 한).
    - 참조 계수(Reference counting) (Collins, 1960)
        - 블록을 이동시키지 않습니다 (논의하지 않음).
    - 복사 수집(Copying collection) (Minsky, 1963)
        - 블록을 이동시킵니다 (논의하지 않음).
    - 세대별 수집기(Generational Collectors) (Lieberman and Hewitt, 1983)
        - 수명(Lifetimes)에 기반한 수집
            - 대부분의 할당은 매우 빨리 가비지가 됩니다.
            - 따라서 최근에 할당된 메모리 영역에 재확보 작업을 집중합니다.
    - 더 많은 정보를 원하시면:
        - Jones and Lin, Garbage Collection: Algorithms for Aut Dynamic Memory , John Wiley & Sons, 1996.

- [51:08](https://www.youtube.com/watch?v=z-Vp5W1qHK8#t=51:08.33)
- 그래프로서의 메모리
    - 우리는 메모리를 유향 그래프(Directed graph)로 봅니다.
        - 각 (힙) 블록은 그래프의 노드입니다.
        - 각 포인터는 그래프의 간선(Edge)입니다.
        - 힙을 가리키는 포인터를 포함하는 힙 외부의 위치를 루트 노드(Root nodes)라고 합니다 (예: 레지스터, 스택 상의 위치, 전역 변수).
            - 이들은 힙에 있는 메모리 위치를 가리키지만, 그 자체는 힙 외부에 있습니다.
        - ![[Pasted image 20251027193006.png]]
        - 따라서 힙에 있는所有这些 흰색 블록들은 도달 가능(Reachable)합니다.
            - 루트 노드에서 시작하여 일련의 포인터를 따라가면 해당 노드에 도달할 수 있기 때문입니다.
        - 노드(블록)는 어떤 루트로부터든 힙 내의 그 노드로의 경로가 존재하면 도달 가능합니다.
        - 도달 불가능한 노드는 가비지입니다 (애플리케이션에서 필요로 할 수 없습니다) - 이를 해제하면 그래프에서 제거됩니다.

- 표시-쓸기(Mark and Sweep) 수집
    - malloc/free 패키지 위에 구축할 수 있습니다.
        - "공간이 부족해질 때까지" malloc을 사용하여 할당합니다.
            - 예: 우리가 사용하기로 한 최대 힙 크기
                - 또는 어떤 시점에서 OS가 가상 메모리 주는 것을 멈출 것입니다.
    - 공간이 부족할 때:
        - 각 블록의 헤더에 추가 표시 비트(Mark bit)를 사용합니다.
        - 표시(Mark): 루트에서 시작하여 각 도달 가능한 블록의 표시 비트를 설정합니다.
            - 루트에서 도달 가능한 노드 집합을 순회(Traverse)하며 각 노드의 표시 비트를 설정합니다. 스위프(Sweep)는 표시가 완료된 후 발생합니다.
        - 쓸기(Sweep): 모든 블록을 스캔하여 표시되지 않은 블록을 해제합니다.
            - ![[Pasted image 20251027195256.png]]
            - 이 예제의 화살표는 메모리 참조를 나타내며, 프리 리스트 포인터가 아닙니다.
            - 블록의 페이로드(Payload) 시작 부분에서 시작합니다.

- [57:02](https://www.youtube.com/watch?v=z-Vp5W1qHK8#t=57:02.29)
- 간단한 구현을 위한 가정
    - 애플리케이션
        - new(n): 모든 위치가 초기화된 새로운 블록에 대한 포인터를 반환합니다.
        - read(b, i): 블록 b의 i 위치를 레지스터로 읽어옵니다.
        - write(b, i, v): v를 블록 b의 i 위치에 씁니다.
    - 각 블록은 헤더 워드(Header word)를 가집니다.
        - 블록 b에 대해 b[-1]로 주소 지정됩니다.
        - 다른 수집기에서 다른 목적으로 사용됩니다.
    - 가비지 컬렉터가 사용하는 명령어
        - is_ptr(p): p가 포인터인지 판단합니다.
        - length(b): 헤더를 포함하지 않는 블록 b의 길이를 반환합니다.
        - get_roots(): 모든 루트를 반환합니다.
    - ![[Pasted image 20251027200446.png]]
    - ptr p는 루트입니다.
    - ![[Pasted image 20251027200515.png]]
    - if (markBitSet(p)) clearMarkBit();
        - 이전 표시를 그대로 두면, 수집기는 한 번 표시된 객체를 *절대 회수하지 않습니다*. 시간이 지남에 따라 **메모리 사용량이 제한 없이 증가**합니다 — 효과적으로 메모리 누수(Memory leak)입니다.
    - else if (allocateBitSet(p))
        - "이 블록은 할당되었지만, 프로그램이 더 이상 참조하지 않습니다."

- [1:00:16](https://www.youtube.com/watch?v=z-Vp5W1qHK8#t=1:00:16.66)
- C 언어에서의 보수적 표시-쓸기(Conservative Mark & Sweep)
- C 프로그램을 위한 "보수적 가비지 컬렉터(Conservative garbage collector)"
    - is_ptr()은 어떤 워드가 할당된 메모리 블록을 가리키는지 확인하여 포인터인지 판단합니다.
    - 하지만 C에서는 포인터가 블록의 중간을 가리킬 수 있습니다.
    - ![[Pasted image 20251027201157.png]]
- 그렇다면 블록의 시작 부분을 어떻게 찾을까요?
    - 할당된 모든 블록을 추적하기 위해 균형 이진 트리(Balanced binary tree)를 사용할 수 있습니다 (키는 블록의 시작 주소).
    - 균형 트리 포인터는 헤더에 저장할 수 있습니다 (두 개의 추가 워드 사용).
    - ![[Pasted image 20251027201246.png]]

- [1:02:03](https://www.youtube.com/watch?v=z-Vp5W1qHK8#t=1:02:03.45)
- 메모리 관련 위험과 함정
    - 잘못된 포인터 역참조(Dereferencing bad pointers)
    - 초기화되지 않은 메모리 읽기(Reading uninitialized memory)
    - 메모리 덮어쓰기(Overwriting memory)
    - 존재하지 않는 변수 참조(Referencing nonexistent variables)
    - 블록 여러 번 해제(Freeing blocks multiple times)
    - 해제된 블록 참조(Referencing freed blocks)
    - 블록 해제 실패(Failing to free blocks)

- [1:04:05](https://www.youtube.com/watch?v=z-Vp5W1qHK8#t=1:04:05.65)
- C 연산자
    - ![[Pasted image 20251027201524.png]]
- ![[Pasted image 20251027202228.png]]
- ![[Pasted image 20251027202320.png]]
- ![[Pasted image 20251027202435.png]]
    - Malloc은 모두 0인 값을 반환하지 않습니다.
- ![[Pasted image 20251027202640.png]]
    - 우리는 int와 포인터의 크기가 같다고 잘못 가정하고 있습니다.
- ![[Pasted image 20251027202814.png]]
- ![[Pasted image 20251027202829.png]]
    - 버퍼의 크기를 확인하지 않습니다.
- ![[Pasted image 20251027203028.png]]
    - 이것은 4가 아니라 16씩 증가시킵니다.
- ![[Pasted image 20251027203249.png]]
    - *(size--)
- ![[Pasted image 20251027203305.png]]
- ![[Pasted image 20251027203337.png]]
- ![[Pasted image 20251027203347.png]]
- ![[Pasted image 20251027203401.png]]
- 메모리 버그 다루기
    - 디버거: gdb
        - 잘못된 포인터 역참조를 찾는 데 좋습니다.
        - 다른 메모리 버그를 발견하기는 어렵습니다.
    - 데이터 구조 일관성 검사기(Data structure consistency checker)
        - 조용히 실행되며, 오류 시에만 메시지를 출력합니다.
        - 오류 위치를 파악하기 위한 프로브(Probe)로 사용합니다.
    - 바이너리 변환기(Binary translator): valgrind
        - 강력한 디버깅 및 분석 기술입니다.
        - 실행 가능 객체 파일의 텍스트 섹션을 재작성합니다.
        - 런타임에 각 개별 참조를 확인합니다.
            - 잘못된 포인터, 덮어쓰기, 할당된 블록 외부 참조
    - glibc malloc에는 확인 코드가 포함되어 있습니다.
        - setenv MALLOC_CHECK_ 3

[파일 내용 끝]