[파일 이름]: 8장.md
[파일 내용 시작]
https://www.youtube.com/watch?v=79yH0NeoEv4&list=PL22J-I2Pi-Gf0s1CGDVtt4vuvlyjLxfem&index=14

제어 흐름
- 시작부터 종료까지, CPU는 단순히 일련의 명령어들을 하나씩 읽고 실행(해석)합니다.
- 이 순서가 CPU의 제어 흐름(Control Flow)입니다.
- 하드웨어가 실제로 실행하는 명령어의 순서를 물리적 제어 흐름(Physical Control Flow)이라고 합니다.
- ![[Pasted image 20251018150314.png]]

제어 흐름 변경
- 지금까지: 제어 흐름을 변경하는 두 가지 메커니즘:
    - 점프(Jumps)와 분기(Branches)
    - 호출(Call)과 반환(Return)
    - 프로그램 상태의 변화에 반응
- 유용한 시스템에 부족한 점:
    - 시스템 상태 변화에 대응하기 어려움
        - 디스크나 네트워크 어댑터로부터 데이터 도착
        - 명령어가 0으로 나누기
        - 사용자가 키보드에서 Ctrl-C 입력
        - 시스템 타이머 만료
    - "예외적 제어 흐름(Exceptional Control Flow)"

예외적 제어 흐름
- 컴퓨터 시스템의 모든 수준에 존재합니다.
- 저수준 메커니즘
    - 1. 예외(Exception)
        - 시스템 이벤트(즉, 시스템 상태 변화)에 대한 응답으로의 제어 흐름 변경
        - 하드웨어와 OS 소프트웨어의 조합으로 구현됨
- 고수준 메커니즘
    - 2. 프로세스 문맥 교환(Process Context Switch)
        - OS 소프트웨어와 하드웨어 타이머에 의해 구현됨
    - 3. 시그널(Signals)
        - OS 소프트웨어에 의해 구현됨
    - 4. 비지역 점프(Nonlocal jumps): setjmp() 및 longjmp()
        - C 런타임 라이브러리에 의해 구현됨

예외
- 예외는 어떤 이벤트(예: 프로세서 상태 변경)에 대한 응답으로 제어를 OS 커널로 전송하는 것입니다.
    - 커널은 OS의 메모리 상주 부분입니다.
        - 파일 목록 보기, 디렉토리 변경, 현재 프로세스 목록 보기 등.
    - 이벤트 예: 0으로 나누기, 산술 오버플로우, 페이지 폴트, I/O 요청 완료, Ctrl-C 입력
    - ![[Pasted image 20251018151115.png]]
- 예외 핸들러는 예외가 발생했을 때 무엇을 해야 하는지 알려주는 OS 내의 코드 조각일 뿐입니다.

- [07:00](https://www.youtube.com/watch?v=79yH0NeoEv4#t=07:00.08)
예외 테이블
- 프로그램 카운터 또는 %rip의 변경과 같은 실제 제어 전송은 하드웨어에 의해 수행됩니다.
- 하지만 그 예외의 결과로 실행되는 코드는 OS 커널에 의해 설정되고 결정됩니다.
- 모든 유형의 이벤트에는 고유한 예외 번호가 있습니다.
    - 이는 예외 테이블(Exception Table)이라는 점프 테이블의 인덱스로 사용됩니다.
    - 이벤트 k가 발생하면, 하드웨어는 k를 이 예외 테이블의 인덱스로 사용합니다. 해당 예외에 대한 예외 핸들러의 주소를 가져옵니다.

- [07:50](https://www.youtube.com/watch?v=79yH0NeoEv4#t=07:50.06)
비동기 예외 (인터럽트)
- 프로세서 외부의 이벤트에 의해 발생
    - 프로세서의 인터럽트 핀을 설정하여 표시됨
    - 핸들러는 "다음" 명령어로 반환합니다.
- 예시:
    - 타이머 인터럽트
        - 몇 밀리초마다 외부 타이머 칩이 인터럽트를 트리거합니다.
        - 커널이 사용자 프로그램으로부터 제어권을 되찾는 데 사용됩니다.
    - 외부 장치로부터의 I/O 인터럽트
        - 키보드에서 Ctrl-C 입력
        - 네트워크로부터 패킷 도착
        - 디스크로부터 데이터 도착

동기 예외
- 명령어 실행의 결과로 발생하는 이벤트에 의해 발생:
- 트랩(Trap)
    - 의도적임
    - 예시: 시스템 호출, 중단점 트랩, 특수 명령어
    - 제어를 "다음" 명령어로 반환합니다.
    - OS 커널은 프로그램에 다양한 서비스를 제공하지만, 프로그램은 직접 접근할 수 없습니다. 프로그램은 커널 내의 함수를 호출할 수 없고, 커널 내의 데이터에 직접 접근할 수 없습니다. 해당 메모리는 보호되어 있으며 사용자 프로그램이 사용할 수 없기 때문입니다.
    - 따라서 커널이 제공하는 것은 프로그램이 커널 내부의 함수를 효과적으로 호출하고 다양한 서비스에 요청을 할 수 있도록 하는 인터페이스입니다. 이 인터페이스를 시스템 호출(System Call)이라고 합니다.
        - 시스템 호출 - 함수 호출처럼 보이지만 실제로는 커널로 제어를 이전합니다.
- 폴트(Fault)
    - 의도적이지 않지만 복구 가능할 수 있음
    - 예시: 페이지 폴트(복구 가능), 보호 폴트(복구 불가능), 부동 소수점 예외
        - 보호 폴트 - 할당되지 않은 메모리 영역에 접근
    - 오류를 발생시킨 ("현재") 명령어를 다시 실행하거나 중단합니다.
- 어보트(Abort)
    - 의도적이지 않고 복구 불가능함
    - 예시:불법 명령어, 패리티 오류, 머신 체크
        - 메모리가 손상되었을 때나 머신에 문제가 있을 때
    - 현재 프로그램을 중단합니다.

- [13:33](https://www.youtube.com/watch?v=79yH0NeoEv4#t=13:33.06)
![[Pasted image 20251018162157.png]]

시스템 호출 예제: 파일 열기
- 사용자 호출: open(파일명, 옵션)
- __open 함수를 호출하며, 이는 시스템 호출 명령어 syscall을 호출합니다.
- ![[Pasted image 20251018153245.png]]

폴트 예제: 페이지 폴트
- 사용자가 메모리 위치에 쓰기
- 사용자 메모리의 해당 부분(페이지)이 현재 디스크에 있음
- 디스크에서 메모리로 로드되어야 함
- ![[Pasted image 20251018153439.png]]

폴트 예제: 잘못된 메모리 참조
- ![[Pasted image 20251018153548.png]]
- 사용자 프로세스에 SIGSEGV 시그널을 보냅니다.
- 사용자 프로세스가 "세그멘테이션 폴트(segmentation fault)"와 함께 종료됩니다.

- [18:24](https://www.youtube.com/watch?v=79yH0NeoEv4#t=18:24.94)
프로세스
- 프로그램은 여러 다른 곳에 존재할 수 있습니다. C 파일의 텍스트로, 바이너리의 .text 섹션으로, 메모리에 로드된 바이트로 존재할 수 있습니다. 반면 프로세스는 실행 중인 프로그램의 인스턴스입니다.

프로세스는 각 프로그램에 두 가지 주요 추상화를 제공합니다:
- 논리적 제어 흐름(Logical Control Flow)
    - 각 프로그램이 CPU를 독점적으로 사용하는 것처럼 보입니다.
    - 문맥 교환(Context Switching)이라는 커널 메커니즘에 의해 제공됩니다.
    - CPU와 레지스터를 독점적으로 사용/접근할 수 있다는 환상을 제공합니다.
    - 프로세스에서 프로그램을 실행할 때, 다른 프로그램이 레지스터를 수정하는 것에 대해 전혀 걱정할 필요가 없으며, 시스템에 다른 프로세스가 실행 중인지조차 알 수 없습니다.
- 사적 주소 공간(Private Address Space)
    - 각 프로그램이 주 메모리를 독점적으로 사용하는 것처럼 보입니다.
    - 가상 메모리(Virtual Memory)라는 커널 메커니즘에 의해 제공됩니다.
    - 우리 자신의 주소 공간을 가지고 있다는 또 다른 환상이며, 이는 가상 메모리라는 메커니즘에 의해 제공됩니다. 따라서 각 실행 중인 프로그램은 자신의 코드, 데이터, 힙, 스택을 가집니다.

![[Pasted image 20251018155116.png]]![[Pasted image 20251018155154.png]]

- [21:39](https://www.youtube.com/watch?v=79yH0NeoEv4#t=21:39.11)
- 현실적으로, 예를 들어 단일 코어를 가지고 있다면, 우리는 실제로 시스템을 공유하고 있으며 OS가 시스템을 관리하는 주체입니다.
- 단일 프로세서가 여러 프로세스를 동시에 실행합니다.
    - 프로세스 실행이 인터리빙(교차)됨 (멀티태스킹)
    - 주소 공간은 가상 메모리 시스템에 의해 관리됨
    - 실행되지 않는 프로세스들의 레지스터 값은 메모리에 저장됨

- ![[Pasted image 20251018155515.png]]
- 현재 레지스터 값을 메모리로 복사하여 저장합니다.

- ![[Pasted image 20251018155646.png]]

- ![[Pasted image 20251018155720.png]]

- ![[Pasted image 20251018155812.png]]
- 따라서 이 프로세스에 대한 주소 공간을 전환합니다 - 주소 공간과 레지스터 값이 문맥(Context)입니다. 따라서 문맥 교환은 주소 공간과 레지스터 값의 변경입니다.

- 멀티코어 프로세서
    - 단일 칩에 여러 CPU
    - 주 메모리(및 일부 캐시)를 공유함
    - 각각 별도의 프로세스를 실행할 수 있음
        - 프로세서의 스케줄링은 커널에 의해 수행됨

- [23:41](https://www.youtube.com/watch?v=79yH0NeoEv4#t=23:41.36)
동시성 프로세스
- 각 프로세스는 논리적 제어 흐름입니다.
- 두 프로세스의 흐름이 시간상 겹치면 동시에 실행된다(Concurrent)고 합니다.
- 그렇지 않으면 순차적(Sequential)입니다.
- 예시 (단일 코어에서 실행):
    - 동시성: A&B, A&C
    - ![[Pasted image 20251018161014.png]]

    - 동시성 프로세스에 대한 사용자 관점
        - 동시성 프로세스들의 제어 흐름은 물리적으로 시간상 분리되어 있습니다.
        - 그러나 우리는 동시성 프로세스들이 서로 병렬적으로 실행되는 것으로 생각할 수 있습니다.

    - ![[Pasted image 20251018161046.png]]

- [26:38](https://www.youtube.com/watch?v=79yH0NeoEv4#t=26:38.36)
문맥 교환
- 프로세스는 커널(Kernel)이라는 공유되는 메모리 상주 OS 코드 덩어리에 의해 관리됩니다.
    - 중요: 커널은 별도의 프로세스가 아니라, 기존 어떤 프로세스의 일부로 실행됩니다.
- 제어 흐름은 문맥 교환(Context Switch)을 통해 한 프로세스에서 다른 프로세스로 전달됩니다.
- 프로세스 A - 예외 발생
    - 제어를 커널로 이전 - 커널은 스케줄러를 호출하여 A가 계속 실행되도록 할지, 아니면 문맥 교환을 수행하여 새로운 다른 프로세스(이 경우 프로세스 B)를 실행할지 결정합니다.
        - 프로세스 B의 주소 공간과 레지스터를 다시 가리키도록 설정합니다.
        - ![[Pasted image 20251018161752.png]]

- [28:20](https://www.youtube.com/watch?v=79yH0NeoEv4#t=28:20.22)
시스템 호출 오류 처리
- 오류 시, Linux 시스템 수준 함수는 일반적으로 -1을 반환하고 전역 변수 errno에 원인을 나타내는 값을 설정합니다.
- 절대적인 규칙:
    - 모든 시스템 수준 함수의 반환 상태를 반드시 확인해야 합니다.
    - exit나 free처럼 void를 반환하는 소수의 함수만이 예외입니다.
    - ![[Pasted image 20251018161958.png]]
    - -1이면 오류
    - ![[Pasted image 20251018162353.png]]

- [33:14](https://www.youtube.com/watch?v=79yH0NeoEv4#t=33:14.72)
프로세스 생성과 종료
- 프로그래머의 관점에서, 프로세스는 세 가지 상태 중 하나에 있다고 생각할 수 있습니다.
- 실행 중(Running)
    - 프로세스가 실행 중이거나, 실행 대기 중이며 커널에 의해 eventually 스케줄될(선택되어 실행될) 것입니다.
- 정지됨(Stopped)
    - 프로세스 실행이 일시 중단되었으며, 추후 통지가 있을 때까지 스케줄되지 않습니다 (다음 강의에서 시그널을 공부할 때 다룸).
- 종료됨(Terminated)
    - 프로세스가 영구적으로 정지되었습니다.

프로세스 종료
- 프로세스는 다음 세 가지 이유 중 하나로 종료됩니다:
    - 종료를 기본 동작으로 하는 시그널을 수신함 (다음 강의)
    - main 루틴에서 반환함
    - exit 함수를 호출함
- void exit(int status)
    - status라는 종료 상태로 종료됩니다.
    - 관례: 정상적인 반환 상태는 0, 오류 시 0이 아닌 값
    - 종료 상태를 명시적으로 설정하는 또 다른 방법은 main 루틴에서 정수 값을 반환하는 것입니다.
- exit는 한 번 호출되지만 절대 반환하지 않습니다.

프로세스 생성
- 부모 프로세스(Parent Process)는 fork를 호출하여 새로운 실행 중인 자식 프로세스(Child Process)를 생성합니다.
- int fork(void)
    - 자식 프로세스에게는 0을, 부모 프로세스에게는 자식의 PID를 반환합니다.
    - 자식은 부모와 거의 동일합니다:
        - 자식은 부모의 가상 주소 공간과 동일한(but 분리된) 복사본을 얻습니다.
            - 모든 전역 변수, 스택, 코드가 부모와 정확히 같습니다.
        - 자식은 부모의 열린 파일 디스크립터들의 동일한 복사본을 얻습니다.
            - stdio처럼
        - 자식은 부모와 다른 PID를 가집니다.
- fork는 한 번 호출되지만 두 번 반환하기 때문에 흥미롭고(종종 혼란스럽습니다).

Fork 예제
- ![[Pasted image 20251018163444.png]]

프로세스 그래프로 fork 모델링하기
    - 프로세스 그래프(Process Graph)는 동시성 프로그램에서 문장들의 부분적 순서(Partial Ordering)를捕捉하는 유용한 도구입니다:
        - 각 꼭짓점(Vertex)은 문장의 실행입니다.
        - a -> b 는 a가 b보다 먼저 발생함을 의미합니다.
        - 간선(Edge)은 변수의 현재 값으로 레이블을 붙일 수 있습니다.
        - printf 꼭짓점은 출력으로 레이블을 붙일 수 있습니다.
        - 각 그래프는 들어오는 간선이 없는 꼭짓점으로 시작합니다.
    - 그래프의 임의의 위상 정렬(Topological Sort)은 실행 가능한 전체 순서(Total Ordering)에 해당합니다.
        - 모든 간선이 왼쪽에서 오른쪽을 가리키는 꼭짓점들의 전체 순서
        - 이 자식이 나타내는 논리적 흐름은 순서대로 발생해야 함, 먼저 'e' 그리고 'f'
        - ![[Pasted image 20251018164529.png]]
        - ![[Pasted image 20251018164709.png]]
        - ![[Pasted image 20251018165005.png]]
        - ![[Pasted image 20251018165024.png]]

- [48:18](https://www.youtube.com/watch?v=79yH0NeoEv4#t=48:18.50)
자식 프로세스 수확(Reaping)
- 개념
    - 프로세스가 종료되어도 여전히 시스템 자원을 소모합니다.
        - 예: 종료 상태, 다양한 OS 테이블
    - "좀비(Zombie)"라고 불립니다.
        - 살아있는 시체, 반은 살아있고 반은 죽은 상태
- 수확(Reaping)
    - 종료된 자식을 부모가 수행함 (wait 또는 waitpid 사용)
    - 부모는 종료 상태 정보를 받습니다.
    - 그런 다음 커널은 좀비 자식 프로세스를 삭제합니다.
- 부모가 수확하지 않으면 어떻게 될까요?
    - 부모가 자식을 수확하지 않고 종료하면, 고아가 된 자식은 init 프로세스(pid == 1)에 의해 수확됩니다.
    - 따라서, 명시적인 수확은 장기 실행 프로세스에서만 필요합니다.
        - 예: 셸(Shells)과 서버(Servers)
        - ![[Pasted image 20251018165817.png]]
        - 자식은 좀비였습니다.

        - ![[Pasted image 20251018165958.png]]

- [54:22](https://www.youtube.com/watch?v=79yH0NeoEv4#t=54:22.09)
- wait: 자식과 동기화
    - 부모는 wait 함수를 호출하여 자식을 수확합니다.
    - int wait(int *child_status)
        - 자식 중 하나가 종료될 때까지 현재 프로세스를 대기(suspend)시킵니다.
        - 반환 값은 종료된 자식 프로세스의 pid입니다.
        - child_status != NULL이면, 그것이 가리키는 정수는 자식이 종료된 이유와 종료 상태를 나타내는 값으로 설정됩니다:
            - wait.h에 정의된 매크로를 사용하여 확인합니다.
            - WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG, WIFCONTINUED
            - 자세한 내용은 교재 참조
- ![[Pasted image 20251018170238.png]]

- [1:00:22](https://www.youtube.com/watch?v=79yH0NeoEv4#t=1:00:22.25)
- 프로세스 내에서 다른 프로그램을 실행하려면 execve라는 함수를 사용합니다.
- int execve(char *filename, char *argv[], char *envp[])
- 현재 프로세스에서 다음을 로드하고 실행합니다:
    - 실행 파일 filename
        - 오브젝트 파일이거나 #! 인터프리터(예: #!/bin/bash)로 시작하는 스크립트 파일일 수 있습니다.
    - ... 인수 리스트 argv와 함께
        - 관례적으로 argv[0] == filename
    - ... 그리고 환경 변수 리스트 envp와 함께
        - "name=value" 문자열 (예: USER=droh)
        - getenv, putenv, printenv
    - 코드, 데이터, 스택을 덮어씁니다.
        - PID, 열린 파일들, 시그널 문맥은 유지합니다.
    - 한 번 호출되며 절대 반환하지 않습니다.
        - ...오류가 발생한 경우를 제외하고

- [1:03:27](https://www.youtube.com/watch?v=79yH0NeoEv4#t=1:03:27.69)
- execve가 작업을 마친 후, 새로운 스택, 새로운 코드와 데이터, 새로운 빈 힙을 생성합니다. 모든 것이 새것입니다.
- argv - 프로그램을 실행할 때 프로그램 이름을 지정합니다. 그리고 공백으로 구분된 인수들입니다.
    - 인수 문자열들을 가리키는 포인터들의 목록
- envp - 환경 변수 문자열들은 키=값 쌍들의 집합입니다.

- [1:06:23](https://www.youtube.com/watch?v=79yH0NeoEv4#t=1:06:23.38)
- 현재 환경을 사용하여 자식 프로세스에서 "/bin/ls -lt /usr/include"를 실행합니다:
- ls - /usr/include 디렉토리의 파일들을 나열합니다.
- -lt - 목록의 긴 형식으로 보여주고 시간 순으로 정렬합니다. 가장 최근 것부터
- ![[Pasted image 20251018172306.png]]
- 요약
    - 예외(Exception)
        - 비표준 제어 흐름을 필요로 하는 이벤트
        - 외부적으로(인터럽트) 또는 내부적으로(트랩과 폴트) 생성됨
    - 프로세스(Process)
        - 주어진 시간에 시스템에는 여러 활성 프로세스가 있습니다.
        - 단일 코어에서는 한 번에 하나만 실행할 수 있습니다.
        - 각 프로세스는 프로세서 + 사적 메모리 공간을 완전히 제어하는 것처럼 보입니다.
    - 프로세스 생성(Spawning Processes)
        - fork 호출
        - 한 번 호출, 두 번 반환
    - 프로세스 완료(Process Completion)
        - exit 호출
        - 한 번 호출, 반환 없음
    - 프로세스 수확 및 대기(Reaping and waiting for processes)
        - wait 및 waitpid 호출
    - 프로그램 로드 및 실행(Loading and running programs)
        - execve (또는 변형) 호출
        - 한 번 호출, (일반적으로) 반환 없음
[파일 내용 끝]