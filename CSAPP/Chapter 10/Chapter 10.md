```timestamp-url 

 ```

 https://www.youtube.com/watch?v=vaOT9KeIUDk&list=PL22J-I2Pi-Gf0s1CGDVtt4vuvlyjLxfem&index=16

- In unix, a file is just sequence of bytes, and unix doesn't distinguish between different classes of files unlike say Windows. The os operating system level has essentially no understanding of a more detailed structure inside of a file.
- Elegant mapping of files to devices allows kernel to export simple interface called Unix I/O:
	- Opening and closing files
		- open () and close ()
	- Reading and writing a file
		- read () and write ()
	- read () and write ()
		- we don't always start with the start, we want to read a data and continuously reading that data
		- indicates next offset into file to read or write
		- lseek ()
		- ![[Pasted image 20251030194003.png]]
		- File position as part of the data associated with the data, telling how far we have read or written
- File Types
	- Each file has a type indicating its role in the system
		- Regular file: Contains arbitrary data
			- The things that are on a disk drive
		- Directory: Index for a related group of files
			- it actually does have an interpretation that entries in that file describe the location and attributes of other files
		- Socket: For communicating with a process on another machine
			- Connection to next, send and receiving the message
			
	- Other file types beyond our scope
		- Named pipes (FIFOs)
		- Symbolic links - 바로가기 폴더
		- Character and block devices
	
-  Regular Files
	- A regular file contains arbitrary data
	- Applications often distinguish between text files and binary files
		- Text files are regular files with only ASCII or Unicode characters
		- Binary files are everything else
			- e.g., object files, JPEG images
		- Kernel doesn’t know the difference! - doesn't happen in the low level
	- Text file is sequence of text lines
		- Text line is sequence of chars terminated by newline char (‘\n’)
			- Newline is 0xa, same as ASCII line feed character (LF)
	- End of line (EOL) indicators in other systems
		- Linux and Mac OS: ‘\n’ (0xa)
			- line feed (LF)
		- Windows and Internet protocols: ‘\r\n’ (0xd 0xa)
			- Carriage return (CR) followed by line feed (LF)
		- Two classes of systems have different ways of interpreting of encoding when is the end of a line.
			- linux or MAC file it's just this character code 0xa
			- In windows files with two characters.
- Directories
	- Directory consists of an array of links
		- Each link maps a filename to a file
	- Each directory contains at least two entries
		- . (dot) is a link to itself
		- .. (dot dot) is a link to the parent directory in the directory hierarchy (next slide)
	- Commands for manipulating directories
		- mkdir: create empty directory
		- ls: view directory contents
		- rmdir: delete empty directory
	- Directory is stored as a file but it's a file that the file system part of operating system interprets in very specific ways.
- Directory Hierarchy
	- All files are organized as a hierarchy anchored by root directory named / (slash)
	- ![[Pasted image 20251030195826.png]]
	- Kernel maintains current working directory (cwd) for each process
		- Modified using the cd command
	- There's a hierarchical organizations that's maintained as a series of files each being the directory and the directory then is a pointer to its subdirectory which again are files
- Pathnames
	- Is a way to navigate through the hierarchy of file and identify the particular file 
	- Locations of files in the hierarchy denoted by pathnames
		- Absolute pathname starts with ‘/’ and denotes path from root
			- /home/droh/hello.c
	- Relative pathname denotes path from current working directory
		- ../home/droh/hello.c
- Opening Files
	- Opening a file informs the kernel that you are getting ready to access that file
	- ![[Pasted image 20251030200455.png]]
		- Given a pathname and integer code - what do you want to do when you open this file and in what form do you want to open it. And this will return a file descriptor
		- ![[Pasted image 20251030201204.png]]
		- 1024 says that you can't have more than 1024 files open at any given time
	- Returns a small identifying integer file descriptor
		- file descriptor - that lists which particular one of the open files that's being used by this particular program are you referring to.
		- fd == -1 indicates that an error occurred
	- Each process created by a Linux shell begins life with three open files associated with a terminal:
		- 0: standard input (stdin)
		- 1: standard output (stdout)
		- 2: standard error (stderr)
- Closing Files
	- Closing a file informs the kernel that you are finished accessing that file
	- ![[Pasted image 20251030201830.png]]
	- put the 'fd' - the file descriptor number not the name of the file
	- Closing an already closed file is a recipe for disaster in threaded programs (more on this later)
	- Moral: Always check return codes, even for seemingly benign functions such as close()
- Reading files
	- Reading a file copies bytes from the current file position to memory, and then updates file position
	- ![[Pasted image 20251030202100.png]]
	- buf - a pointer to the buffer that we've allocated either static or via malloc
	- sizeof(buf) - how long is the buffer so that it can't overflow that buffer
	- read() - just means read as many bytes as you feel like but no more than the number we tell you to.
		- Returns number of bytes read from file fd into buf
			- Return type ssize_t is signed integer
			- nbytes < 0 indicates that an error occurred 
				- if it's negative then it's a error code
			- Short counts (nbytes < sizeof(buf) ) are possible and are not errors!
			- if it's positive then that's the number of bytes that were read
- Writing Files
	- Writing a file copies bytes from memory to the current file position, and then updates current file position
	- ![[Pasted image 20251030202940.png]]
	- Returns number of bytes written from buf to file fd
		- nbytes < 0 indicates that an error occurred
		- As with reads, short counts are possible and are not errors!
			- it can potentially not send them all
		
- Simple Unix I/O example
	- Copying file to stdout, one byte at a time
	- ![[Pasted image 20251030203115.png]]
		-  This is really bad code - Read and write is expensive call
			- It means kicking your whole operation up to the operating system doing what's called a context switch. Meaning it will go into the kernel of the system invoke operating system functions. Do whatever the read or write tells it to do come back out switch back to your job. It will typically take maybe 20000 to 40000 clock cycles
	- ![[Pasted image 20251030203748.png]]
	- ./cpstdin - the code above
	- strace - will detect every system call to the operating system functions that you make when you run a program.
	- ![[Pasted image 20251030203910.png]]
	- ![[Pasted image 20251030203938.png]]
- On Short Counts
	- Short counts can occur in these situations:
		- Encountering (end-of-file) EOF on reads
			- Case 1 - we are near the end of a file, we have hundred bytes left and you say read 200.
				- First call to read will get 100 character it would say 100 and it will get that number.
				- Second call again the second time and it will return zero. 
					- The only case that we will get a read of zero is at the end-of-file.
		- Reading text lines from a terminal
		- Reading and writing network sockets
	- Short counts never occur in these situations:
		- Reading from disk files (except for EOF)
		- Writing to disk files
	- Best practice is to always allow for short counts.

- The RIO Package
	- RIO is a set of wrappers that provide efficient and robust I/O in apps, such as network programs that are subject to short counts
		- RIO provides two different kinds of functions
			- Unbuffered input and output of binary data
				- rio_readn and rio_writen
					- Ex. rio_readn with some number of bytes - then that function will not return until it's read that number of bytes so better be careful that many bytes are there if it's a network socket or a file, because it will hang up.
			- Buffered input of text lines and binary data
				- rio_readlineb and rio_readnb
					- Buffered RIO routines are thread-safe and can be interleaved arbitrarily on the same descriptor
					- Within the user code build up a little buffer of bytes before it's actually out of the network.
	- Unbuffered RIO Input and Output
		- Same interface as Unix read and write
		- Especially useful for transferring data on network sockets
		- rio_readn returns short count only if it encounters EOF 
			- Only use it when you know how many bytes to read
		- rio_writen never returns a short count
		- Calls to rio_readn and rio_writen can be interleaved arbitrarily on the same descriptor
		- ![[Pasted image 20251030210059.png]]
	- Buffered RIO Input Functions
		- For reading from file
		- File has associated buffer to hold bytes that have been read from file but not yet read by user code
		- ![[Pasted image 20251030211020.png]]
		- ![[Pasted image 20251030211244.png]]
		- ![[Pasted image 20251030211418.png]]
- File Metadata
	- Metadata is data about data, in this case file data
	- Per-file metadata maintained by kernel
		- accessed by users with the stat and fstat functions
		- Read / write protection, info about the ownership of that file, what type it is, and time - when created, when change, when modified.
		- ![[Pasted image 20251030211555.png]]
		- ![[Pasted image 20251030211950.png]]
		- chmod 000 - set all protection to zero
		- ![[Pasted image 20251030212231.png]]
		- man 2 stat
		- ![[Pasted image 20251030212349.png]]
- How the Unix Kernel Represents Open Files
	- Two descriptors referencing two distinct open files. Descriptor 1 (stdout) points to terminal, and descriptor 4 points to open disk file
	- The main point is that associated with any executing process - which we can think of a process as a running program - is something called a descriptor table
		- And what that contain is for every open file you have it has a pointer to a data structure called  open file table
			- open file table - a table that's maintained by the operating system globally and which describes each of the open files.
				- Actually, every time a file is opened that allocates a record in this open file table
	- Open file table
		- File pos - In regular file at least, there's associated position of where in the file was your last read or write. Or  where would be your next read or write
		- refcnt = used by OS to keep track of 
			- There's possibility that multiple processes sharing, an entry on this open file table.
			- Uses this reference count which is a standard way of keeping track of memory allocation to know when it no longer needs that entry when the file is no longer accessible and therefore this entry is not needed
	- Virtual node table
		- Information about file
		- ![[Pasted image 20251030213658.png]]
- File sharing
	- Two distinct descriptors sharing the same disk file through two distinct open file table entries
		- E.g., Calling open twice with the same filename argument
	- Within a single program, you call open twice on the same function
		- This file descriptors might be referring to the same file but they're actually at different positions within the file
		- ![[Pasted image 20251030214044.png]]
- How Processes Share Files: fork
	- A child process inherits its parent’s open files
		- Note: situation unchanged by exec functions (use fcntl to change)
		- ![[Pasted image 20251030214153.png]]
		- The child inherits a lot of information from its parent, and one of the things it inherits is the descriptor table it gets the replica of the descriptor table
		- ![[Pasted image 20251030214343.png]]
- I/O redirection
	- Question: How does a shell implement I/O redirection?
		- linux> ls > foo.txt
	- Answer: By calling the dup2(oldfd, newfd) function
		- Copies (per-process) descriptor table entry oldfd to entry newfd
		- ![[Pasted image 20251030214710.png]]
	- step #1: open file to which stdout should be redirected
		- Happens in child executing shell code, before exec
		- ![[Pasted image 20251030214756.png]]
	- Step #2: call dup2(4,1)
		- cause fd=1 (stdout) to refer to disk file pointed at by fd=4
		- ![[Pasted image 20251030214821.png]]
- Standard I/O Functions
	- The C standard library (libc.so) contains a collection of higher-level standard I/O functions
	- Examples of standard I/O functions:
		- Opening and closing files (fopen and fclose)
		- Reading and writing bytes (fread and fwrite)
		- Reading and writing text lines (fgets and fputs)
		- Formatted reading and writing (fscanf and fprintf)
	- Implementing as Unix I/O calls expensive
		- read and write require Unix kernel calls
			- > 10,000 clock cycles
	- Solution: Buffered read
		- Use Unix read to grab block of bytes
		- User input functions take one byte at a time from buffer
			- Refill buffer when empty
			- ![[Pasted image 20251030215142.png]]
- Buffering in Standard I/O
	- ![[Pasted image 20251030215250.png]]
	- Standard I/O functions use buffered I/O
	- ![[Pasted image 20251030215347.png]]
- closing remark
	- ![[Pasted image 20251030215429.png]]
- Pros and Cons of Unix I/O
	- Pros
	- Unix I/O is the most general and lowest overhead form of I/O
		- All other I/O packages are implemented using Unix I/O functions
	- Unix I/O provides functions for accessing file metadata
	- Unix I/O functions are async-signal-safe and can be used safely in signal handlers
	- Cons
	- Dealing with short counts is tricky and error prone
	- Efficient reading of text lines requires some form of buffering, also tricky and error prone
	- Both of these issues are addressed by the standard I/O and RIO packages
- Pros and Cons of Standard I/O
	- Pros:
	- Buffering increases efficiency by decreasing the number of read and write system calls
	- Short counts are handled automatically
	- Cons:
	- Provides no function for accessing file metadata
	- Standard I/O functions are not async-signal-safe, and not appropriate for signal handlers
	- Standard I/O is not appropriate for input and output on network sockets
		- There are poorly documented restrictions on streams that interact badly with restrictions on sockets (CS:APP3e, Sec 10.11)
- Choosing I/O Functions
	- General rule: use the highest-level I/O functions you can
		- Many C programmers are able to do all of their work using the standard I/O functions
		- But, be sure to understand the functions you use!
	- When to use standard I/O
		- When working with disk or terminal files
	- When to use raw Unix I/O
		- Inside signal handlers, because Unix I/O is async-signal-safe
		- In rare cases when you need absolute highest performance
	- When to use RIO
		- When you are reading and writing network sockets
		- Avoid using standard I/O on sockets
- Aside: Working with Binary Files
	- Binary File
		- Sequence of arbitrary bytes
		- Including byte value 0x00
	- Functions you should never use on binary files
		- Text-oriented I/O: such as fgets, scanf, rio_readlineb
			- Interpret EOL characters.
			- Use functions like rio_readn or rio_readnb instead
		- String functions
			- strlen, strcpy, strcat
			- Interprets byte value 0 (end of string) as special