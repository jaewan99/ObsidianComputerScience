```timestamp-url 

 ```

 https://www.youtube.com/watch?v=vaOT9KeIUDk&list=PL22J-I2Pi-Gf0s1CGDVtt4vuvlyjLxfem&index=16

- In unix, a file is just sequence of bytes, and unix doesn't distinguish between different classes of files unlike say Windows. The os operating system level has essentially no understanding of a more detailed structure inside of a file.
- Elegant mapping of files to devices allows kernel to export simple interface called Unix I/O:
	- Opening and closing files
		- open () and close ()
	- Reading and writing a file
		- read () and write ()
	- read () and write ()
		- we don't always start with the start, we want to read a data and continuously reading that data
		- indicates next offset into file to read or write
		- lseek ()
		- ![[Pasted image 20251030194003.png]]
		- File position as part of the data associated with the data, telling how far we have read or written
- File Types
	- Each file has a type indicating its role in the system
		- Regular file: Contains arbitrary data
			- The things that are on a disk drive
		- Directory: Index for a related group of files
			- it actually does have an interpretation that entries in that file describe the location and attributes of other files
		- Socket: For communicating with a process on another machine
			- Connection to next, send and receiving the message
			
	- Other file types beyond our scope
		- Named pipes (FIFOs)
		- Symbolic links
		- Character and block devices
	
-  Regular Files
	- A regular file contains arbitrary data
	- Applications often distinguish between text files and binary files
		- Text files are regular files with only ASCII or Unicode characters
		- Binary files are everything else
			- e.g., object files, JPEG images
		- Kernel doesn’t know the difference! - doesn't happen in the low level
	- Text file is sequence of text lines
		- Text line is sequence of chars terminated by newline char (‘\n’)
			- Newline is 0xa, same as ASCII line feed character (LF)
	- End of line (EOL) indicators in other systems
		- Linux and Mac OS: ‘\n’ (0xa)
			- line feed (LF)
		- Windows and Internet protocols: ‘\r\n’ (0xd 0xa)
			- Carriage return (CR) followed by line feed (LF)
		- Two classes of systems have different ways of interpreting of encoding when is the end of a line.
			- linux or MAC file it's just this character code 0xa
			- In windows files with two characters.
- Directories
	- Directory consists of an array of links
		- Each link maps a filename to a file
	- Each directory contains at least two entries
		- . (dot) is a link to itself
		- .. (dot dot) is a link to the parent directory in the directory hierarchy (next slide)
	- Commands for manipulating directories
		- mkdir: create empty directory
		- ls: view directory contents
		- rmdir: delete empty directory
	- Directory is stored as a file but it's a file that the file system part of operating system interprets in very specific ways.
- Directory Hierarchy
	- All files are organized as a hierarchy anchored by root directory named / (slash)
	- ![[Pasted image 20251030195826.png]]
	- Kernel maintains current working directory (cwd) for each process
		- Modified using the cd command
	- There's a hierarchical organizations that's maintained as a series of files each being the directory and the directory then is a pointer to its subdirectory which again are files
- Pathnames
	- Is a way to navigate through the hierarchy of file and identify the particular file 
	- Locations of files in the hierarchy denoted by pathnames
		- Absolute pathname starts with ‘/’ and denotes path from root
			- /home/droh/hello.c
	- Relative pathname denotes path from current working directory
		- ../home/droh/hello.c
- Opening Files
	- Opening a file informs the kernel that you are getting ready to access that file
	- ![[Pasted image 20251030200455.png]]
		- Given a pathname and integer code - what do you want to do when you open this file and in what form do you want to open it. And this will return a file descriptor
		- ![[Pasted image 20251030201204.png]]
		- 1024 says that you can't have more than 1024 files open at any given time
	- Returns a small identifying integer file descriptor
		- file descriptor - that lists which particular one of the open files that's being used by this particular program are you referring to.
		- fd == -1 indicates that an error occurred
	- Each process created by a Linux shell begins life with three open files associated with a terminal:
		- 0: standard input (stdin)
		- 1: standard output (stdout)
		- 2: standard error (stderr)
- Closing Files
	- Closing a file informs the kernel that you are finished accessing that file
	- ![[Pasted image 20251030201830.png]]
	- put the 'fd' - the file descriptor number not the name of the file
	- Closing an already closed file is a recipe for disaster in threaded programs (more on this later)
	- Moral: Always check return codes, even for seemingly benign functions such as close()
- Reading files
	- Reading a file copies bytes from the current file position to memory, and then updates file position
	- ![[Pasted image 20251030202100.png]]
	- buf - a pointer to the buffer that we've allocated either static or via malloc
	- sizeof(buf) - how long is the buffer so that it can't overflow that buffer
	- read() - just means read as many bytes as you feel like but no more than the number we tell you to.
		- Returns number of bytes read from file fd into buf
			- Return type ssize_t is signed integer
			- nbytes < 0 indicates that an error occurred 
				- if it's negative then it's a error code
			- Short counts (nbytes < sizeof(buf) ) are possible and are not errors!
			- if it's positive then that's the number of bytes that were read
- Writing Files
	- Writing a file copies bytes from memory to the current file position, and then updates current file position
	- ![[Pasted image 20251030202940.png]]
	- Returns number of bytes written from buf to file fd
		- nbytes < 0 indicates that an error occurred
		- As with reads, short counts are possible and are not errors!
			- it can potentially not send them all
		
- Simple Unix I/O example
	- Copying file to stdout, one byte at a time
	- ![[Pasted image 20251030203115.png]]
		-  This is really bad code - Read and write is expensive call
			- It means kicking your whole operation up to the operating system doing what's called a context switch. Meaning it will go into the kernel of the system invoke operating system functions. Do whatever the read or write tells it to do come back out switch back to your job. It will typically take maybe 20000 to 40000 clock cycles
	- ![[Pasted image 20251030203748.png]]
	- ./cpstdin - the code above
	- strace - will detect every system call to the operating system functions that you make when you run a program.
	- ![[Pasted image 20251030203910.png]]
	- ![[Pasted image 20251030203938.png]]
- On Short Counts
	- Short counts can occur in these situations:
		- Encountering (end-of-file) EOF on reads
			- Case 1 - we are near the end of a file, we have hundred bytes left and you say read 200, 
		- Reading text lines from a terminal
		- Reading and writing network sockets
	- Short counts never occur in these situations:
		- Reading from disk files (except for EOF)
		- Writing to disk files
	- Best practice is to always allow for short counts.