# 7.1 링커

https://www.youtube.com/watch?v=mO9l0n3BmLw&list=PL22J-I2Pi-Gf0s1CGDVtt4vuvlyjLxfem&index=13

![[Pasted image 20251017163009.png]]
- 두 개의 모듈을 컴파일할 때 어떤 일이 발생하는지 살펴봅시다.
- ![[Pasted image 20251017163417.png]]
    - GCC는 해당 C 파일들에 대해 일련의 변환기(translator)를 호출합니다.
        - cpp - C 전처리기
        - cc1 - 실제 컴파일러
        - as - 어셈블리어로 변환
    - 링커는 이 두 개의 .o 파일을 가져와 연결하여 단일 실행 파일을 만들고, 시스템에 로드하여 실행합니다.
    - 왜 링커를 사용할까요?
        - 이유 1: 모듈성
            - 프로그램을 하나의 거대한 덩어리 대신 더 작은 소스 파일들의 모음으로 작성할 수 있습니다.
            - 공통 함수들의 라이브러리를 구축할 수 있습니다 (나중에 자세히 설명).
                - 예: 수학 라이브러리, 표준 C 라이브러리
        - 이유 2: 효율성
            - 시간: 분리 컴파일
                - 하나의 소스 파일을 변경하고, 컴파일한 후 다시 링크합니다.
                - 다른 소스 파일들을 다시 컴파일할 필요가 없습니다.
            - 공간: 라이브러리
                - 공통 함수들을 하나의 파일로 집계할 수 있습니다...
                - 그러나 실행 파일과 실행 중인 메모리 이미지에는 실제로 사용하는 함수들의 코드만 포함됩니다.
            - 공간 측면에서도 효율적입니다. C 라이브러리의 모든 함수를 가져올 수 있지만, 우리가 실제로 사용하는 함수만 링크하고 전체를 링크하지는 않기 때문입니다.

---

[05:27](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=05:27.17)

## 링커는 무엇을 하는가?

-   단계 1: 심볼 해석 (Symbol Resolution)
    -   프로그램은 심볼(전역 변수와 함수)을 정의하고 참조합니다:
        -   `void swap () { ... }` - /* 심볼 swap 정의 */
        -   `swap();` - /* 심볼 swap 참조 */
        -   `int *xp = &x;` - /* 심볼 xp 정의, x 참조 */
    -   심볼 정의는 어셈블러에 의해 오브젝트 파일의 심볼 테이블에 저장됩니다.
        -   심볼 테이블은 구조체 배열입니다.
        -   각 항목에는 심볼의 이름, 크기, 위치가 포함됩니다.
    -   심볼 해석 단계에서 링커는 각 심볼 참조를 정확히 하나의 심볼 정의와 연결합니다.
-   단계 2: 재배치 (Relocation)
    -   분리된 코드와 데이터 섹션을 단일 섹션으로 병합합니다.
    -   심볼들을 .o 파일 내의 상대적 위치에서 실행 파일 내 최종 절대 메모리 위치로 재배치합니다.
    -   이러한 심볼들에 대한 모든 참조를 새로운 위치를 반영하도록 업데이트합니다.
    -   각 심볼, 각 함수, 각 변수가 어디에 저장될지 파악해야 하는데, 이를 재배치라고 합니다. 왜냐하면 처음에는 함수들이 단지 해당 오브젝트 모듈 내의 어떤 오프셋에 저장되어 있기 때문입니다. 링커는 그 함수들이 실제로 메모리의 어디에 로드될지 모르기 때문입니다.

---

[09:14](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=09:14.08)

## 세 가지 종류의 오브젝트 파일 (모듈)

-   재배치 가능 오브젝트 파일 (.o 파일)
    -   다른 재배치 가능 오브젝트 파일들과 결합하여 실행 가능 오브젝트 파일을 형성할 수 있는 형태의 코드와 데이터를 포함합니다.
    -   각 .o 파일은 정확히 하나의 소스(.c) 파일로부터 생성됩니다.
    -   이는 어셈블러의 출력물입니다.
    -   바이너리 형태이지만 메모리에 직접 로드될 수 있는 형태는 아닙니다 - 링커에 의해 조작되어야 합니다.
-   실행 가능 오브젝트 파일 (a.out 파일)
    -   메모리에 직접 복사되어 실행될 수 있는 형태의 코드와 데이터를 포함합니다.
    -   링커에 의해 생성됩니다.
-   공유 오브젝트 파일 (.so 파일)
    -   메모리에 로드되고, 로드 시점이나 실행 시점에 동적으로 링크될 수 있는 특별한 유형의 재배치 가능 오브젝트 파일입니다.
    -   **Windows**에서는 동적 링크 라이브러리(DLLs)라고 불립니다.

---

[10:36](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=10:36.36)

## 실행 및 링크 가능 형식 (ELF - Executable and Linkable Format)

-   오브젝트 파일을 위한 표준 바이너리 형식
-   하나의 통합 형식으로 다음을 포함합니다:
    -   재배치 가능 오브젝트 파일 (.o)
    -   실행 가능 오브젝트 파일 (a.out)
    -   공유 오브젝트 파일 (.so)
-   일반적인 이름: ELF 바이너리

![[Pasted image 20251017165027.png]]

-   **ELF 헤더**: 워드 크기, 바이트 순서, 파일 타입(.o, exec, .so), 머신 타입 등. 이 바이너리에 대한 일반 정보를 제공합니다.
-   **세그먼트 헤더 테이블**: 페이지 크기, 가상 주소 메모리 세그먼트(섹션), 세그먼트 크기. 실행 가능 오브젝트 파일에만 정의됩니다. 코드의 다양한 세그먼트들이 메모리의 어디로 갈지 나타냅니다. (스택, 공유 라이브러리, 초기화/비초기화 데이터, 코드의 위치)
-   **.text 섹션**: 코드 자체 - 읽기 전용입니다.
-   **.rodata 섹션**: 읽기 전용 데이터: 점프 테이블, 스위치 테이블
-   **.data 섹션**: 초기화된 전역 변수. 지역 C 변수들은 런타임에 스택에서 관리되며 .data나 .bss 섹션에 나타나지 않습니다.
-   **.bss 섹션**: 초기화되지 않은 전역 변수, "Block Started by Symbol", "Better Save Space". 섹션 헤더는 있지만 공간을 차지하지 않습니다.
-   **.symtab 섹션**: 심볼 테이블, 프로시저와 정적 변수 이름, 섹션 이름과 위치.
-   **.rel.text 섹션**
    -   .text 섹션에 대한 재배치 정보
    -   실행 파일에서 수정이 필요한 명령어들의 주소
    -   수정 방법에 대한 지시사항.
-   **.rel.data 섹션**
    -   .rel.data 섹션
    -   병합된 실행 파일에서 수정이 필요한 포인터 데이터의 주소
    -   **재배치 항목(relocation entry)은 어셈블러가 링커에게 남기는 노트와 같습니다. "이 참조를 고쳐야 할 거야"라고 말이죠. 어셈블러는 이 심볼이 로드될 때 메모리의 어디에 실제로 저장될지 모르기 때문입니다.**
-   **.debug 섹션**
    -   심볼릭 디버깅을 위한 정보 (gcc -g)
    -   소스 코드의 줄 번호와 머신 코드의 줄 번호를 연결하는 정보를 포함합니다.
-   **섹션 헤더 테이블**
    -   각 섹션의 오프셋과 크기 - 모든 이러한 다른 섹션들이 어디서 시작하는지 알려줍니다.

---

[15:17](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=15:17.45)

## 링커 심볼 (Linker Symbols)

-   **전역 심볼 (Global symbols)**
    -   모듈 m에 의해 정의되고 다른 모듈들에서 참조될 수 있는 심볼들.
    -   예: 비정적(non-static) C 함수와 비정적 전역 변수.
-   **외부 심볼 (External symbols)**
    -   모듈 m에 의해 참조되지만 다른 모듈에 의해 정의된 전역 심볼들.
    -   main 함수가 sum을 호출 - main은 외부 심볼을 호출합니다.
-   **지역 심볼 (Local symbols)**
    -   모듈 m에 의해 독점적으로 정의되고 참조되는 심볼들.
    -   예: static 속성으로 정의된 C 함수와 전역 변수
    -   지역 링커 심볼들은 지역 프로그램 변수와 다릅니다.
    -   컴파일러가 스택에서 관리하는 지역 C 변수와는 다릅니다. 링커는 지역 C 변수에 대해 알지 못합니다. 여기서는 해당 모듈 내에서만 참조될 수 있는 static이 붙은 전역 변수나 함수에 대해 이야기합니다.
    -   모듈 외부에서 호출할 수 없는 private 함수 - static으로 선언.

---

[19:04](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=19:04.54)

## 심볼 해석 (Symbol Resolution)

![[Pasted image 20251017171217.png]]
-   링커는 지역 C 변수에 대해 아무것도 모릅니다.

### 지역 심볼 (Local Symbols)

-   비정적 지역 C 변수 vs. 정적 지역 C 변수
    -   비정적 지역 C 변수: 스택에 저장됨
    -   정적 지역 C 변수: .bss 또는 .data에 저장됨
    -   ![[Pasted image 20251017171555.png]]
    -   컴파일러는 각 x의 정의에 대해 .data 공간을 할당합니다.
    -   고유한 이름(예: x.1 및 x.2)을 가진 심볼 테이블에 지역 심볼을 생성합니다.

### 중복 심볼 정의를 링커가 해결하는 방법

-   프로그램 심볼은 강한(Strong) 심볼이나 약한(Weak) 심볼입니다.
    -   강한 심볼: 프로시저와 초기화된 전역 변수
    -   약한 심볼: 초기화되지 않은 전역 변수
    -   ![[Pasted image 20251017171828.png]]

### 링커의 심볼 규칙

-   규칙 1: 여러 개의 강한 심볼은 허용되지 않습니다.
    -   각 항목은 한 번만 정의되어야 합니다.
    -   그렇지 않으면: 링커 오류
-   규칙 2: 하나의 강한 심볼과 여러 개의 약한 심볼이 주어지면, 강한 심볼을 선택합니다.
    -   약한 심볼에 대한 참조는 강한 심볼로 해결됩니다.
-   규칙 3: 여러 개의 약한 심볼이 있으면, 임의의 것을 선택합니다.
    -   `gcc -fno-common`으로 이를 재정의할 수 있습니다.
    -   `-fno-common`: 여러 개의 약한 심볼이 오류를 발생시킵니다.

### 링커 퍼즐 (Linker Puzzles)

![[Pasted image 20251017173154.png]]

-   4번째 질문: p2에서 x에 대한 쓰기는 8바이트가 됩니다. 컴파일러는 그것이 double이라고 알고 있기 때문이지만, 링커가 강한 심볼을 선택했기 때문에 4바이트만 있는 메모리 위치에 갑니다. 따라서 p2에서 x에 대한 쓰기는 y를 덮어쓰게 됩니다.
-   그렇다면 `double x;`는 메모리에 어떻게 영향을 미치나요?
    -   컴파일러는 `p2()`를 위해 `x`가 `double`(8바이트)이라고 가정하고 코드를 생성합니다.
    -   링커는 `x`를 `int`(4바이트)로 해석하므로, 할당된 메모리는 4바이트뿐입니다.
    -   런타임에 `p2()`는 8바이트를 써서 `y`로 오버플로우됩니다.

---

[32:11](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=32:11.25)

## 전역 변수 (Global Variables)

-   가능하다면 사용을 피하세요.
-   그렇지 않다면:
    -   가능하다면 `static`을 사용하세요.
    -   전역 변수를 정의한다면 초기화하세요.
    -   외부 전역 변수를 참조한다면 `extern`을 사용하세요.

---

[32:57](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=32:57.90)

## 단계 2: 재배치 (Relocation)

-   링커가 이러한 오브젝트 파일들을 재배치할 때, 각 모듈의 .text 섹션을 가져와 실행 파일의 .text 섹션에 연속적으로 배치합니다. 이 섹션은 시스템 코드와 모듈에 정의된 모든 코드를 포함합니다. 데이터도 마찬가지입니다.
-   ![[Pasted image 20251017175341.png]]
-   main()을 가리킬 절대 주소를 선택해야 합니다.
    -   문제는 이 코드가 컴파일될 때, 컴파일러는 링커가 선택할 주소를 모른다는 점입니다.

---

[39:25](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=39:25.10)

## 재배치 항목 (Relocation Entries)

![[Pasted image 20251017185938.png]]
![[Pasted image 20251017185926.png]]

1.  임시로 0의 즉시값(immediate value)을 %edi로 이동시킵니다. bf = 이동(move) 명령어입니다.
    -   a: 링커에게 오프셋 'a'를 알려줍니다 - 함수(main)는 오프셋 0에서 시작합니다.
    -   32: 32비트 주소를 참조합니다 - "bf" 다음 변경 - 00 00 00 00 - 32비트
3.  오프셋 'f': sum이라는 함수에 대한 4바이트 pc-relative -0x4 - 현재 %rip 값에서의 오프셋으로 편향됨(biased).

![[Pasted image 20251017191016.png]]
![[Pasted image 20251017191151.png]]

-   컴파일러가 재배치 항목을 계산했습니다. 맅커는 각 재배치 항목을 무작정 순회하면서 지시된 대로 수행할 뿐입니다. 이제所有这些 참조들이 유효한 절대 주소로 패치(patch up)되었습니다.

---

[44:07](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=44:07.01)

![[Pasted image 20251017192048.png]]

-   모든 프로그램은 이 동일한 주소 0x400000에 로드됩니다.
-   그 뒤를 런타임 힙(runtime heap)이 따르며, 이는 malloc에 의해 생성되고 관리됩니다. (동적으로 메모리를 할당해야 할 때)
-   스택(Stack)은 응용 프로그램 프로그램에 사용 가능한 가시 메모리의 가장 상단에 있습니다.
-   그 위는 커널(Kernel)이며, 해당 메모리 위치에 접근하려고 하면 세그폴트(seg fault)가 발생합니다.
-   메모리 매핑 영역(Memory-mapped region)은 .so 파일 등을 저장합니다.

---

[48:20](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=48:20.89)

## 일반적으로 사용되는 함수 패키징 (Packaging Commonly Used Functions)

-   다른 프로그램에서 일반적으로 사용되는 함수를 어떻게 사용 가능하게 만들 수 있을까요?
    -   프로그래머들이 일반적으로 사용하는 함수들을 어떻게 패키징할까요?
        -   수학, I/O, 메모리 관리, 문자열 조작 등.
    -   지금까지의 링커 프레임워크로는 어색합니다:
        -   옵션 1: 모든 함수를 하나의 소스 파일에 넣기
            -   프로그래머들이 큰 오브젝트 파일을 자신의 프로그램에 링크합니다.
            -   공간과 시간 비효율적입니다.
        -   옵션 2: 각 함수를 별도의 소스 파일에 넣기
            -   프로그래머들이 명시적으로 적절한 바이너리를 자신의 프로그램에 링크합니다.
            -   더 효율적이지만, 프로그래머에게 부담을 줍니다.

### 구식 해결책: 정적 라이브러리 (Static Libraries)

-   정적 라이브러리 (.a 아카이브 파일)
    -   .o 파일들의 모음이며, 각 .o 파일은 하나의 함수를 포함합니다. 아카이브(archive)는 단순히 .o 파일들을 연결한(concatenated) collection입니다. 그리고 이 아카이브를 링커에 전달하면, 참조된 .o 파일들만 가져와 코드에 링크합니다. 예: printf만 호출하면, 우리가 얻는 .o 파일은 printf.o 뿐입니다.
    -   관련된 재배치 가능 오브젝트 파일들을 인덱스가 있는 단일 파일(아카이브라고 함)로 연결합니다.
    -   하나 이상의 아카이브에서 심볼을 찾아 해결되지 않은 외부 참조(unresolved external references)를 해결하려고 시도하도록 링커를 향상시킵니다.
    -   아카이브 멤버 파일이 참조를 해결하면, 실행 파일에 링크합니다.
-   ![[Pasted image 20251017192914.png]]
-   예를 들어, printf가 변경되면, printf를 다시 컴파일하고 .o 파일들을 다시 아카이브하면 됩니다.

---

[53:50](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=53:50.08)

## 정적 라이브러리와 링크 (Linking with Static Library)

![[Pasted image 20251017193333.png]]
![[Pasted image 20251017193446.png]]

-   addvec.o만 가져오고 나머지는 무시합니다. 마찬가지로 printf.o도요.

---

[56:20](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=56:20.36)

## 정적 라이브러리 사용 (Using Static Libraries)

-   외부 참조를 해결하기 위한 링커의 알고리즘:
    -   명령줄 순서대로 .o 파일과 .a 파일을 스캔합니다.
    -   스캔 동안 현재 해결되지 않은 참조들의 목록을 유지합니다.
        -   예를 들어, main 함수에서 printf가 정의되지 않았으므로, printf는 해결되지 않은 참조 목록에 들어갑니다.
    -   각 새로운 .o 또는 .a 파일(obj)이 encountered될 때마다, 목록에 있는 각 해결되지 않은 참조를 obj에 정의된 심볼들에 대해 해결하려고 시도합니다.
    -   스캔 끝에 해결되지 않은 목록에 항목이 남아 있으면 오류입니다.
-   문제점:
    -   명령줄 순서가 중요합니다!
    -   교훈: 라이브러리를 명령줄 끝에 두세요.
    -   순서가 중요합니다:
        -   `unix> gcc -L. libtest.o -lmine`
            -   `-L.` - 현재 디렉토리에서 먼저 라이브러리 파일을 찾으세요.
            -   오브젝트 모듈 libtest - 'lmine.a'에 정의된 함수를 호출합니다.
            -   `-lmine` == lmine.a
            -   `libtest.o: In function 'main':`
        -   `unix> gcc -L. -lmine libtest.o`
            -   `-lmine`은 잘 동작합니다.
            -   `libtest.o` - 'libfun'에 대한 해결되지 않은 참조 (이는 '-lmine'에서 얻을 수 있습니다)
            -   `libtest.o(.text+0x4): undefined reference to 'libfun'` (오류 발생)

---

[1:00:06](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=1:00:06.11)

## 현대적 해결책: 공유 라이브러리 (Shared Libraries)

### 정적 라이브러리의 단점:

-   저장된 실행 파일 내 중복 (모든 함수가 libc가 필요함)
-   실행 중인 실행 파일 내 중복
-   시스템 라이브러리의 사소한 버그 수정이 각 응용 프로그램의 명시적인 재링크를 요구합니다
-   정적 라이브러리의 단점 (잠재적 중복) - printf를 사용하는 모든 함수가 printf의 사본을 가짐. 공유 라이브러리는 printf와 같은 공유 라이브러리 멤버의 하나의 인스턴스를 허용하고 그 하나의 복사본을 공유합니다.

### 현대적 해결책: 공유 라이브러리 (Shared Libraries)

-   동적으로, 로드 시점이나 실행 시점에 응용 프로그램에 로드되고 링크되는 코드와 데이터를 포함하는 오브젝트 파일들.
-   동적 링크 라이브러리(Dynamic Link Libraries, DLLs), .so 파일이라고도 불립니다.
-   동적 링크는 실행 파일이 처음 로드되고 실행될 때 발생할 수 있습니다 (로드-타임 링킹, load-time linking).
    -   Linux의 일반적인 경우이며, 동적 링커(ld-linux.so)에 의해 자동으로 처리됩니다.
    -   표준 C 라이브러리(libc.so)는 보통 동적으로 링크됩니다.
-   동적 링크는 프로그램이 시작된 후에도 발생할 수 있습니다 (런-타임 링킹, run-time linking).
    -   Linux에서는 `dlopen()` 인터페이스를 호출하여 수행됩니다.
        -   소프트웨어 배포.
        -   고성능 웹 서버.
        -   런타임 라이브러리 인터포지셔닝(Runtime library interpositioning).
    -   공유 라이브러리 루틴들은 여러 프로세스들에 의해 공유될 수 있습니다.
        -   가상 메모리에 대해 배울 때 더 자세히 설명합니다.

---

[1:02:52](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=1:02:52.31)

![[Pasted image 20251017195249.png]]

-   링커(ld) - 링커는 실제로 printf와 addvec을 사용한다고 해서 그 함수들을 복사하거나 실행 파일에서 아무 작업도 하지 않습니다. 단지 **심볼 테이블**에 프로그램이 로드될 때 이 함수들에 대한 참조가 해결되어야 한다는 note만 남깁니다.
-   로더(Loader) - 실행 파일을 메모리에 로드하고 실행하는 시스템 호출입니다.
-   로더는 동적 링커(Dynamic Linker)를 호출합니다 - 그리고 .so 파일들을 가져와 해결되지 않은 모든 참조들을 해결합니다.
-   addvec과 printf 함수들의 주소는 프로그램이 로드될 때까지 동적 링커에 의해 결정되지 않습니다.

---

[1:08:06](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=1:08:06.04)

-   또한 `dlopen`, `dlsym`을 사용하여 런타임에 동적 링킹을 할 수도 있습니다.

---

[1:10:13](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=1:10:13.76)

## 링킹 요약 (Linking Summary)

-   링킹은 프로그램이 여러 오브젝트 파일들로부터 구성될 수 있게 하는 기술입니다.
-   링킹은 프로그램 수명 주기 내에서 다른 시점에 발생할 수 있습니다:
    -   컴파일 타임 (프로그램이 컴파일될 때)
    -   로드 타임 (프로그램이 메모리에 로드될 때)
    -   런 타임 (프로그램이 실행되는 동안)
-   링킹을 이해하면 심각한 오류를 피하고 더 나은 프로그래머가 되는 데 도움이 될 수 있습니다.

---

[1:12:01](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=1:12:01.42)

## 사례 연구: 라이브러리 인터포지셔닝 (Library Interpositioning)

-   라이브러리 인터포지셔닝: 프로그래머들이 임의의 함수에 대한 호출을 가로챌 수 있게 하는 강력한 링킹 기술입니다.
-   인터포지셔닝은 다음 시점에 발생할 수 있습니다:
    -   컴파일 타임: 소스 코드가 컴파일될 때
    -   링크 타임: 재배치 가능 오브젝트 파일들이 정적으로 링크되어 실행 가능 오브젝트 파일을 형성할 때
    -   로드/런 타임: 실행 가능 오브젝트 파일이 메모리에 로드되고, 동적으로 링크된 후 실행될 때.

### 일부 인터포지셔닝 응용 분야

-   보안 (Security)
    -   감금 (Sandboxing)
    -   배후 암호화 (Behind the scenes encryption)
-   디버깅 (Debugging)
    -   2014년, 두 명의 Facebook 엔지니어들이 인터포지셔닝을 사용하여 iPhone 앱의 까다로운 1년 된 버그를 디버깅했습니다.
    -   SPDY 네트워킹 스택의 코드가 잘못된 위치에 쓰고 있었습니다.
    -   Posix 쓰기 함수(write, writev, pwrite)에 대한 호출을 가로채서 해결했습니다.
-   모니터링 및 프로파일링 (Monitoring and Profiling)
    -   함수 호출 횟수 계산
    -   호출 사이트 및 함수 인자 특성화
    -   Malloc 추적
        -   메모리 누수 감지
        -   주소 트레이스 생성

---

[1:14:02](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=1:14:02.00)

## 예제 프로그램 (Example program)

(원문 내용에 구체적인 예제 코드는 포함되어 있지 않습니다)