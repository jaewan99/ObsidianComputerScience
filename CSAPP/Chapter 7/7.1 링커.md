https://www.youtube.com/watch?v=mO9l0n3BmLw&list=PL22J-I2Pi-Gf0s1CGDVtt4vuvlyjLxfem&index=13

![[Pasted image 20251017163009.png]]-
- let's see what happens if when we want to compile those two modules
- ![[Pasted image 20251017163417.png]]
	- The GCC calls a series of translators on that on those c files.
		- cpp - c preprocessor
		- cc1 - the actual compiler
		- as - and translated to assembly
	- The linker takes those two 2 .o file and links them together to form a single executable and then we load and run on the system
	- Why Linkers?
		- Reason 1: Modularity
			- Program can be written as a collection of smaller source files, rather than one monolithic mass.
			- Can build libraries of common functions (more on this later)
				- e.g., Math library, standard C library
		- Reason 2: Efficiency
			- Time: Separate compilation
				- Change one source file, compile, and then relink.
				- No need to recompile other source files.
			- Space: Libraries
				- Common functions can be aggregated into a single file ...
				- Yet executable files and running memory images contain only code for the functions they actually use.
			- It's also efficient in space, because you can take all of the function in the c library, and we can only link the function that we only use not all


- [05:27](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=05:27.17) 
- What Do Linkers Do?
	- Step 1: Symbol resolution
		- Programs define and reference symbols (global variables and functions):
			- void swap () { ... } - /* define symbol swap */
			- swap(); - /* reference symbol swap */
			- int *xp = &x; - /* define symbol xp, reference x */
		- Symbol definitions are stored in object file (by assembler) in symbol table.
			- Symbol table is an array of structs
			- Each entry includes name, size, and location of symbol.
		- During symbol resolution step, the linker associates each symbol reference with exactly one symbol definition.
	- Step 2: Relocation
		- Merges separate code and data sections into single sections
		- Relocates symbols from their relative locations in the . o files to their final absolute memory locations in the executable.
		- Updates all references to these symbols to reflect their new positions.
		- It has to figure out where each symbol, each function and each variable in going to be stored and this is called relocation because initially functions are just stored at some offset in their object module. - Because the linker doesn't know where those functions are actually going to be eventually loaded into memory


- [09:14](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=09:14.08) 
- Three Kinds of Object Files (Modules)
	- Relocatable object file (. o file)
		- Contains code and data in a form that can be combined with other relocatable object files to form executable object file.
			- Each . o file is produced from exactly one source (. c) file
			- This is the output of assembler
			- it's in binary form but it's not in any form that can be directly loaded into memory - it needs to be manipulated by linker
	- Executable object file (a. out file)
		- Contains code and data in a form that can be copied directly into memory and then executed.
		- generated by linker
	- Shared object file (.so file)
		- Special type of relocatable object file that can be loaded into memory and linked dynamically, at either load time or run-time
		- Called Dynamic Link Libraries (DLLs) by **Windows**


- [10:36](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=10:36.36) 
- Executable and Linkable Format (ELF)
- Standard binary format for object files
	- One unified format for
		- Relocatable object files (.o),
		- Executable object files (a.out)
		- Shared object files (. so)
	- Generic name: ELF binaries
- ![[Pasted image 20251017165027.png]]
- Elf header - Word size, byte ordering, file type (.o,exec, .so), machine type, etc. It provides general information about this binary
- Segment header table - Page size, virtual addresses memory segments (sections), segment sizes. It's only define for executable object files. And indicates where all the different segments of the code are going to go in memory. So where does your stack go, where do your shared libraries go. Where does your initialized and uninitialized data. Where does your go.
- . text section - the code itself - this is only read-only
-  .rodata section - Read only data: jump tables, switch tables
- .data section - Initialized global variables. Local C variables are maintained at run time on the stack and do not appear in either the .data or .bss sections
- .bss section - Uninitialized global variables, "Block Started by Symbol", "Better Save Space", Has section header but occupies no space.
- . symtab section - Symbol table, Procedure and static variable names, Section names and locations. 
- .rel. text section
	- Relocation info for . text section
	- Addresses of instructions that will need to be modified in the executable
	- Instructions for modifying.
- .rel.data section
	- .rel.data section
	- Addresses of pointer data that will need to be modified in the merged executable
	- **relocation entry is just like that it's a note that the assembler makes to the linker to say hey you're going to have to fix up this reference. Because assembler doesn't know where this symbol is actually going to be stored in memory when it's loaded.**
- .debug section
	- Info for symbolic debugging (gcc -g)
	- that contains information that relates to the line numbers to in the source code to line numbers in the machine code.
- Section header table
	- Offsets and sizes of each section - that tells you where all these different section start.

- [15:17](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=15:17.45) 
- Linker Symbols
	- Global symbols
		- Symbols defined by module m that can be referenced by other modules.
		- E.g .: non-static C functions and non-static global variables.
	- External symbols
		- Global symbols that are referenced by module m but defined by some other module.
		- main function calling sum - the main is calling the external symbol
	- Local symbols
		- Symbols that are defined and referenced exclusively by module m.
		- E.g .: C functions and global variables defined with the static attribute
		- Local linker symbols are not local program variables
		- Different from the local C variables  are managed by the compiler on the stack. Linker has no idea about local C variable. Here, we are talking about global variable or function with static, that can only be referenced from within that module.
		- private function that can't be call from the outside the module - declare with static abstraction.


- [19:04](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=19:04.54) 
- Symbol Resolution - 심볼해석
	- ![[Pasted image 20251017171217.png]]
	- The linker doesn't know anything about local C variables.
- Local Symbols
	- Local non-static C variables vs. local static C variables
		- local non-static C variables: stored on the stack
		- local static C variables: stored in either .bss, or . data
		- ![[Pasted image 20251017171555.png]]
		- Compiler allocates space in . data for each definition of x
		- Creates local symbols in the symbol table with unique names, e.g., x. 1 and x.2.
- How Linker Resolves Duplicate Symbol Definitions
	- Program symbols are either strong or weak
		- Strong: procedures and initialized globals
		- Weak: uninitialized globals
		- ![[Pasted image 20251017171828.png]]
- Linker's Symbol Rules
	- Rule 1: Multiple strong symbols are not allowed
		- Each item can be defined only once
		- Otherwise: Linker error
	- Rule 2: Given a strong symbol and multiple weak symbols, choose the strong symbol.
		- References to the weak symbol resolve to the strong symbol
	- Rule 3: If there are multiple weak symbols, pick an arbitrary one
		- Can override this with gcc -fno-common
		- -fno-common - multiple weak symbols will throw an error
- Linker Puzzles
	- ![[Pasted image 20251017173154.png]]
	- 4th question -  So writes to x in p2 will be 8 bytes, because the compiler knows it's a double, but it'll go to a memory location that's only 4 bytes - because the linker chose the stronger symbol. So the writes to x in p2 will overwrite y.
	- But then how does `double x;` affect memory?
		- The compiler generates code for `p2()` assuming `x` is `double` (8 bytes).
		- The linker resolves `x` as `int` (4 bytes), so the allocated memory is only 4 bytes.
		- At runtime, `p2()` writes 8 bytes, overflowing into `y`.

- [32:11](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=32:11.25) 
- Global variables
	- avoid if you can
	- Otherwise
		- use static if you can
		- Initialize if you define a global variable
		- Use extern if you reference an external global variable


- [32:57](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=32:57.90) 
- Step 2: Relocation
	- When the linker relocated these object files, it takes the .text section in each of the module. and puts them together contiguously in the .text section of the exectuable file