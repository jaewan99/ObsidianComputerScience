https://www.youtube.com/watch?v=mO9l0n3BmLw&list=PL22J-I2Pi-Gf0s1CGDVtt4vuvlyjLxfem&index=13

![[Pasted image 20251017163009.png]]-
- let's see what happens if when we want to compile those two modules
- ![[Pasted image 20251017163417.png]]
	- The GCC calls a series of translators on that on those c files.
		- cpp - c preprocessor
		- cc1 - the actual compiler
		- as - and translated to assembly
	- The linker takes those two 2 .o file and links them together to form a single executable and then we load and run on the system
	- Why Linkers?
		- Reason 1: Modularity
			- Program can be written as a collection of smaller source files, rather than one monolithic mass.
			- Can build libraries of common functions (more on this later)
				- e.g., Math library, standard C library
		- Reason 2: Efficiency
			- Time: Separate compilation
				- Change one source file, compile, and then relink.
				- No need to recompile other source files.
			- Space: Libraries
				- Common functions can be aggregated into a single file ...
				- Yet executable files and running memory images contain only code for the functions they actually use.
			- It's also efficient in space, because you can take all of the function in the c library, and we can only link the function that we only use not all


- [05:27](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=05:27.17) 
- What Do Linkers Do?
	- Step 1: Symbol resolution
		- Programs define and reference symbols (global variables and functions):
			- void swap () { ... } - /* define symbol swap */
			- swap(); - /* reference symbol swap */
			- int *xp = &x; - /* define symbol xp, reference x */
		- Symbol definitions are stored in object file (by assembler) in symbol table.
			- Symbol table is an array of structs
			- Each entry includes name, size, and location of symbol.
		- During symbol resolution step, the linker associates each symbol reference with exactly one symbol definition.
	- Step 2: Relocation
		- Merges separate code and data sections into single sections
		- Relocates symbols from their relative locations in the . o files to their final absolute memory locations in the executable.
		- Updates all references to these symbols to reflect their new positions.
		- It has to figure out where each symbol, each function and each variable in going to be stored and this is called relocation because initially functions are just stored at some offset in their object module. - Because the linker doesn't know where those functions are actually going to be eventually loaded into memory


- [09:14](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=09:14.08) 
- Three Kinds of Object Files (Modules)
	- Relocatable object file (. o file)
		- Contains code and data in a form that can be combined with other relocatable object files to form executable object file.
			- Each . o file is produced from exactly one source (. c) file
			- This is the output of assembler
			- it's in binary form but it's not in any form that can be directly loaded into memory - it needs to be manipulated by linker
	- Executable object file (a. out file)
		- Contains code and data in a form that can be copied directly into memory and then executed.
		- generated by linker
	- Shared object file (.so file)
		- Special type of relocatable object file that can be loaded into memory and linked dynamically, at either load time or run-time
		- Called Dynamic Link Libraries (DLLs) by **Windows**


- [10:36](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=10:36.36) 
- Executable and Linkable Format (ELF)
- Standard binary format for object files
	- One unified format for
		- Relocatable object files (.o),
		- Executable object files (a.out)
		- Shared object files (. so)
	- Generic name: ELF binaries
- ![[Pasted image 20251017165027.png]]
- Elf header - Word size, byte ordering, file type (.o,exec, .so), machine type, etc. It provides general information about this binary
- Segment header table - Page size, virtual addresses memory segments (sections), segment sizes. It's only define for executable object files. And indicates where all the different segments of the code are going to go in memory. So where does your stack go, where do your shared libraries go. Where does your initialized and uninitialized data. Where does your go.
- . text section - the code itself - this is only read-only
-  .rodata section - Read only data: jump tables, switch tables
- .data section - Initialized global variables. Local C variables are maintained at run time on the stack and do not appear in either the .data or .bss sections
- .bss section - Uninitialized global variables, "Block Started by Symbol", "Better Save Space", Has section header but occupies no space.
- . symtab section - Symbol table, Procedure and static variable names, Section names and locations. 
- .rel. text section
	- Relocation info for . text section
	- Addresses of instructions that will need to be modified in the executable
	- Instructions for modifying.
	- relocation entry is just like that it's a note that the assembler makes to the linker to say hey you're going to have to fix up this reference. Because assembler doesn't know where this symbol is actually going to be stored in memory when it's loaded.
- 