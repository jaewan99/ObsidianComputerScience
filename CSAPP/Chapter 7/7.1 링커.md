https://www.youtube.com/watch?v=mO9l0n3BmLw&list=PL22J-I2Pi-Gf0s1CGDVtt4vuvlyjLxfem&index=13

![[Pasted image 20251017163009.png]]-
- let's see what happens if when we want to compile those two modules
- ![[Pasted image 20251017163417.png]]
	- The GCC calls a series of translators on that on those c files.
		- cpp - c preprocessor
		- cc1 - the actual compiler
		- as - and translated to assembly
	- The linker takes those two 2 .o file and links them together to form a single executable and then we load and run on the system
	- Why Linkers?
		- Reason 1: Modularity
			- Program can be written as a collection of smaller source files, rather than one monolithic mass.
			- Can build libraries of common functions (more on this later)
				- e.g., Math library, standard C library
		- Reason 2: Efficiency
			- Time: Separate compilation
				- Change one source file, compile, and then relink.
				- No need to recompile other source files.
			- Space: Libraries
				- Common functions can be aggregated into a single file ...
				- Yet executable files and running memory images contain only code for the functions they actually use.
			- It's also efficient in space, because you can take all of the function in the c library, and we can only link the function that we only use not all


- [05:27](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=05:27.17) 
- What Do Linkers Do?
	- Step 1: Symbol resolution
		- Programs define and reference symbols (global variables and functions):
			- void swap () { ... } - /* define symbol swap */
			- swap(); - /* reference symbol swap */
			- int *xp = &x; - /* define symbol xp, reference x */
		- Symbol definitions are stored in object file (by assembler) in symbol table.
			- Symbol table is an array of structs
			- Each entry includes name, size, and location of symbol.
		- During symbol resolution step, the linker associates each symbol reference with exactly one symbol definition.
	- Step 2: Relocation
		- Merges separate code and data sections into single sections
		- Relocates symbols from their relative locations in the . o files to their final absolute memory locations in the executable.
		- Updates all references to these symbols to reflect their new positions.
		- It has to figure out where each symbol, each function and each variable in going to be stored and this is called relocation because initially functions are just stored at some offset in their object module. - Because the linker doesn't know where those functions are actually going to be eventually loaded into memory


- [09:14](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=09:14.08) 
- Three Kinds of Object Files (Modules)
	- Relocatable object file (. o file)
		- Contains code and data in a form that can be combined with other relocatable object files to form executable object file.
			- Each . o file is produced from exactly one source (. c) file
			- This is the output of assembler
			- it's in binary form but it's not in any form that can be directly loaded into memory - it needs to be manipulated by linker
	- Executable object file (a. out file)
		- Contains code and data in a form that can be copied directly into memory and then executed.
		- generated by linker
	- Shared object file (.so file)
		- Special type of relocatable object file that can be loaded into memory and linked dynamically, at either load time or run-time
		- Called Dynamic Link Libraries (DLLs) by **Windows**


- [10:36](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=10:36.36) 
- Executable and Linkable Format (ELF)
- Standard binary format for object files
	- One unified format for
		- Relocatable object files (.o),
		- Executable object files (a.out)
		- Shared object files (. so)
	- Generic name: ELF binaries
- ![[Pasted image 20251017165027.png]]
- Elf header - Word size, byte ordering, file type (.o,exec, .so), machine type, etc. It provides general information about this binary
- Segment header table - Page size, virtual addresses memory segments (sections), segment sizes. It's only define for executable object files. And indicates where all the different segments of the code are going to go in memory. So where does your stack go, where do your shared libraries go. Where does your initialized and uninitialized data. Where does your go.
- . text section - the code itself - this is only read-only
-  .rodata section - Read only data: jump tables, switch tables
- .data section - Initialized global variables. Local C variables are maintained at run time on the stack and do not appear in either the .data or .bss sections
- .bss section - Uninitialized global variables, "Block Started by Symbol", "Better Save Space", Has section header but occupies no space.
- . symtab section - Symbol table, Procedure and static variable names, Section names and locations. 
- .rel. text section
	- Relocation info for . text section
	- Addresses of instructions that will need to be modified in the executable
	- Instructions for modifying.
- .rel.data section
	- .rel.data section
	- Addresses of pointer data that will need to be modified in the merged executable
	- **relocation entry is just like that it's a note that the assembler makes to the linker to say hey you're going to have to fix up this reference. Because assembler doesn't know where this symbol is actually going to be stored in memory when it's loaded.**
- .debug section
	- Info for symbolic debugging (gcc -g)
	- that contains information that relates to the line numbers to in the source code to line numbers in the machine code.
- Section header table
	- Offsets and sizes of each section - that tells you where all these different section start.

- [15:17](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=15:17.45) 
- Linker Symbols
	- Global symbols
		- Symbols defined by module m that can be referenced by other modules.
		- E.g .: non-static C functions and non-static global variables.
	- External symbols
		- Global symbols that are referenced by module m but defined by some other module.
		- main function calling sum - the main is calling the external symbol
	- Local symbols
		- Symbols that are defined and referenced exclusively by module m.
		- E.g .: C functions and global variables defined with the static attribute
		- Local linker symbols are not local program variables
		- Different from the local C variables  are managed by the compiler on the stack. Linker has no idea about local C variable. Here, we are talking about global variable or function with static, that can only be referenced from within that module.
		- private function that can't be call from the outside the module - declare with static abstraction.


- [19:04](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=19:04.54) 
- Symbol Resolution - 심볼해석
	- ![[Pasted image 20251017171217.png]]
	- The linker doesn't know anything about local C variables.
- Local Symbols
	- Local non-static C variables vs. local static C variables
		- local non-static C variables: stored on the stack
		- local static C variables: stored in either .bss, or . data
		- ![[Pasted image 20251017171555.png]]
		- Compiler allocates space in . data for each definition of x
		- Creates local symbols in the symbol table with unique names, e.g., x. 1 and x.2.
- How Linker Resolves Duplicate Symbol Definitions
	- Program symbols are either strong or weak
		- Strong: procedures and initialized globals
		- Weak: uninitialized globals
		- ![[Pasted image 20251017171828.png]]
- Linker's Symbol Rules
	- Rule 1: Multiple strong symbols are not allowed
		- Each item can be defined only once
		- Otherwise: Linker error
	- Rule 2: Given a strong symbol and multiple weak symbols, choose the strong symbol.
		- References to the weak symbol resolve to the strong symbol
	- Rule 3: If there are multiple weak symbols, pick an arbitrary one
		- Can override this with gcc -fno-common
		- -fno-common - multiple weak symbols will throw an error
- Linker Puzzles
	- ![[Pasted image 20251017173154.png]]
	- 4th question -  So writes to x in p2 will be 8 bytes, because the compiler knows it's a double, but it'll go to a memory location that's only 4 bytes - because the linker chose the stronger symbol. So the writes to x in p2 will overwrite y.
	- But then how does `double x;` affect memory?
		- The compiler generates code for `p2()` assuming `x` is `double` (8 bytes).
		- The linker resolves `x` as `int` (4 bytes), so the allocated memory is only 4 bytes.
		- At runtime, `p2()` writes 8 bytes, overflowing into `y`.

- [32:11](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=32:11.25) 
- Global variables
	- avoid if you can
	- Otherwise
		- use static if you can
		- Initialize if you define a global variable
		- Use extern if you reference an external global variable


- [32:57](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=32:57.90) 
- Step 2: Relocation
	- When the linker relocated these object files, it takes the .text section in each of the module. and puts them together contiguously in the .text section of the executable file - which contains all of the system code and the all of the code define on the modules / also for the data.
	- ![[Pasted image 20251017175341.png]]
	- It has to pick an absolute address to point the main()
		- The problem is that when this code is complied, the compiler doesn't know what addresses the linker is going to pick.



- [39:25](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=39:25.10) 
- Relocation Entries
- ![[Pasted image 20251017185938.png]]
- ![[Pasted image 20251017185926.png]]
- 1 - It moves in an immediate value of 0 into %edi temporarily right so you can see this is all zeroes. - bf = the move instruction
	- a - tells to the linkers - offset 'a' - the function (main) function starts with the offset 0.
	- 32 - reference to the 32 address - changes after the "bf" - 00 00 00 00 - 32 bits
- 3. offset 'f' - 4 bytes pc-relative to a function called sum. -0x4 - biased to the offset from the current %rip value.
- ![[Pasted image 20251017191016.png]]
- ![[Pasted image 20251017191151.png]]
- The compiler computed the relocation entry. The linker is blindly going through each of those relocation entries and just doing what it's told. So now all these references have been patched up with valid absolute addresses.


- [44:07](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=44:07.01) 
- ![[Pasted image 20251017192048.png]]
- every program is loaded at this same address 0x400000
- And followed by a runtime heap, which is created and managed by malloc, so when you need dynamically need to allocate memory.
- Stack is very top of the visible memory that's available to application programs.
- Above that is kernel, if you try to access those memory location you'll get a seg fault.
- memory-mapped region stores like .so file.


- [48:20](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=48:20.89) 
- Packaging Commonly Used Functions - How can we make commonly used functions available to other programs.
	- How to package functions commonly used by programmers?
		- Math, I/O, memory management, string manipulation, etc.
	- Awkward, given the linker framework so far:
		- Option 1: Put all functions into a single source file
			- Programmers link big object file into their programs
			- Space and time inefficient
		- Option 2: Put each function in a separate source file
			- Programmers explicitly link appropriate binaries into their programs
			- More efficient, but burdensome on the programmer
- Old-fashioned Solution: Static Libraries
	- Static libraries (.a archive files)
		- collections of .o file where which .o file contains a function. Archive is just concatenated collection of .o files. And pass that archive to the linker. and it only takes the .o files that are referenced and links them into the code. ex. if we only call printf, the only .o file we get is printf.o
		- Concatenate related relocatable object files into a single file with an index (called an archive).
		- Enhance linker so that it tries to resolve unresolved external references by looking for the symbols in one or more archives.
		- If an archive member file resolves reference, link it into the executable.
	- ![[Pasted image 20251017192914.png]]
	- For example, if printf changes, we just and recompile printf and reachive .o files.


- [53:50](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=53:50.08) 
- Linking with static library
	- ![[Pasted image 20251017193333.png]]
	-  ![[Pasted image 20251017193446.png]]
	- It just pulls addvec.o and ignores the rest, similarly printf.o.

- [56:20](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=56:20.36) 
- Using Static Libraries
	- Linker's algorithm for resolving external references:
		- Scan . o files and . a files in the command line order.
		- During the scan, keep a list of the current unresolved references.
			- example, in main function, printf is not define, so printf goes to the unresolve references.
		- As each new . o or . a file, obj, is encountered, try to resolve each unresolved reference in the list against the symbols defined in obj.
		- If any entries in the unresolved list at end of scan, then error.
	- Problem:
		- Command line order matters!
		- Moral: put libraries at the end of the command line.
		- The order matters
			- unix> gcc -L. libtest.o -lmine
				- -L. - look for library files in the current directory first
				- object module libtest - that calls function that's define in 'lmine.a'
				- -lmine  == lmine.a
				- libtest.o: In function 'main':
			- unix> gcc -L. -lmine libtest.o
				- -lmine works fine
				- libtest.o - unresolved reference to 'libfun' which we can get from '-lmine'
				- libtest.o(.text+0x4): undefined reference to 'libfun'

- [1:00:06](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=1:00:06.11) 
- Modern Solution: Shared Libraries
- Static libraries have the following disadvantages:
	- Duplication in the stored executables (every function needs libc)
	- Duplication in the running executables
	- Minor bug fixes of system libraries require each application to explicitly relink
	- Disadvantages of static (potential duplication) - then every function that uses has a copy of printf. shared libraries allows one instance of a shared library member like printf and share that one copy. 
- Modern solution: Shared Libraries
	- Object files that contain code and data that are loaded and linked into an application dynamically, at either load-time or run-time. when actually it's loaded in the memory or anytime in runtime.
	- Also called: dynamic link libraries, DLLs, . so files
	- Dynamic linking can occur when executable is first loaded and run (load-time linking).
		- Common case for Linux, handled automatically by the dynamic linker (1d-linux.so).
		- Standard C library (libc. so) usually dynamically linked.
	- Dynamic linking can also occur after program has begun (run-time linking).
		- In Linux, this is done by calls to the dlopen () interface.
			- Distributing software.
			- High-performance web servers.
			- Runtime library interpositioning.
		- Shared library routines can be shared by multiple processes
			- More on this when we learn about virtual memory


- [1:02:52](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=1:02:52.31) 
- ![[Pasted image 20251017195249.png]]
- linker (id) - the linker doesn't actually copy that say we are using printf and addvec, it doesn't actaully copy those functions or do anything with them in the executable, it just make note in the **symbol table** that references to those functions will need to be resolved when the program is loaded.  
- loader - sys call that loads executables into memory and runs them
- the loader calls the dynamic linker - and takes those .so files and resolves all the references to any unresolved references.
- The address of addvec and printf functions aren't determined by the dynamic linker until the program is loaded. 

- [1:08:06](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=1:08:06.04) 
- And we can also do dynamic linking at run-time - using dlopen, dlsym



- [1:10:13](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=1:10:13.76) 
- Linking Summary
	- Linking is a technique that allows programs to be constructed from multiple object files.
	- Linking can happen at different times in a program's lifetime:
		- Compile time (when a program is compiled)
		- Load time (when a program is loaded into memory)
		- Run time (while a program is executing)
	- Understanding linking can help you avoid nasty errors and make you a better programmer.