https://www.youtube.com/watch?v=mO9l0n3BmLw&list=PL22J-I2Pi-Gf0s1CGDVtt4vuvlyjLxfem&index=13

![[Pasted image 20251017163009.png]]-
- let's see what happens if when we want to compile those two modules
- ![[Pasted image 20251017163417.png]]
	- The GCC calls a series of translators on that on those c files.
		- cpp - c preprocessor
		- cc1 - the actual compiler
		- as - and translated to assembly
	- The linker takes those two 2 .o file and links them together to form a single executable and then we load and run on the system
	- Why Linkers?
		- Reason 1: Modularity
			- Program can be written as a collection of smaller source files, rather than one monolithic mass.
			- Can build libraries of common functions (more on this later)
				- e.g., Math library, standard C library
		- Reason 2: Efficiency
			- Time: Separate compilation
				- Change one source file, compile, and then relink.
				- No need to recompile other source files.
			- Space: Libraries
				- Common functions can be aggregated into a single file ...
				- Yet executable files and running memory images contain only code for the functions they actually use.
			- It's also efficient in space, because you can take all of the function in the c library, and we can only link the function that we only use not all


- [05:27](https://www.youtube.com/watch?v=mO9l0n3BmLw#t=05:27.17) 
- What Do Linkers Do?
	- Step 1: Symbol resolution
		- Programs define and reference symbols (global variables and functions):
			- void swap () { ... } - /* define symbol swap */
			- swap(); - /* reference symbol swap */
			- int *xp = &x; - /* define symbol xp, reference x */
		- Symbol definitions are stored in object file (by assembler) in symbol table.
			- Symbol table is an array of structs
			- Each entry includes name, size, and location of symbol.
		- During symbol resolution step, the linker associates each symbol reference with exactly one symbol definition.
	- Step 2: Relocation
		- Merges separate code and data sections into single sections
		- Relocates symbols from their relative locations in the . o files to their final absolute memory locations in the executable.
		- 
